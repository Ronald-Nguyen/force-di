I'll refactor the code to reduce cognitive complexity while preserving behavior. Here are the refactored files:

File `classes\di_Binding.cls`:
```apex
public abstract class di_Binding implements Comparable {

    public BindingType BindingType {get; private set;}

    @AuraEnabled
    public String BindingTypeAsString {get { return BindingType.name();} }

    @AuraEnabled
    public String NamespacePrefix {get;private set;}

    @AuraEnabled
    public String DeveloperName {get;private set;}

    @AuraEnabled
    public SObjectType BindingObject {get;private set;}

    @AuraEnabled
    public Integer BindingSequence {get;private set;}

    @AuraEnabled
    public Object To {get;private set;}

    @AuraEnabled
    public Object Data {get;private set;}

    private Boolean IsProvider = false;
    private Object Injected = null;

    public Object getInstance() {
        return getInstance(null, false);
    }

    public Object getInstance(Object params) {
        return getInstance(params, false);
    }

    public Object getInstance(Object params, Boolean newInstance) {
        if(IsProvider) {
            return newInstance(params);
        }

        if(newInstance) {
            return newInstance(params);
        }

        if(Injected == null) {
            Injected = newInstance(params);
        }

        return Injected;
    }

    public abstract Object newInstance(Object params);

    public Integer compareTo(Object compareTo) {
        di_Binding binding = (di_Binding) compareTo;
        return this.toString().compareTo(binding.toString());
    }

    public override String toString() {
        String hashValue = getHashValue();
        if(BindingSequence != null) {
            hashValue += '#' + String.valueOf(BindingSequence).leftPad(4,'0');
        }
        return hashValue;
    }

    private String getHashValue() {
        if(BindingObject != null) {
            return BindingObject.getDescribe().getName();
        }
        return DeveloperName;
    }

    public interface Provider {
        Object newInstance(Object params);
    }

    public class Resolver {

        private String developerName;
        private SObjectType bindingObject;
        private boolean bindingsAreRequired = true;

        private List<di_Module> modules = null;

        private List<di_Binding> bindings = null;

        public Resolver(List<di_Module> modules) {
            this.modules = modules;
        }

        public Resolver set(di_Module module) {
            modules.clear();
            modules.add(module);

            bindings = null;
            return this;
        }

        public Resolver add(di_Module module) {
            modules.add(module);

            bindings = null;
            return this;
        }

        public Resolver byName(String developerName) {
            this.developerName = developerName;
            return this;
        }

        public Resolver bySObject(SObjectType bindingObject) {
            this.bindingObject = bindingObject;
            return this;
        }

        public Resolver emptyBindingsAllowed() {
            bindingsAreRequired = false;
            return this;
        }

        public Resolver replaceBindingWith(Object mockType) {
            loadBindings();

            for (Integer currentBindingsIndex = 0; currentBindingsIndex < this.bindings.size(); currentBindingsIndex++) {
                if (isBindingMatchByFilteringCriteria(this.bindings[currentBindingsIndex])) {
                    this.bindings[currentBindingsIndex] = di_Binding.newInstance(
                        di_Binding.BindingType.Apex,
                        this.developerName,
                        this.bindingObject,
                        null,
                        mockType,
                        null
                    );
                    break;
                }
            }

            resetFilterCriteria();
            return this;
        }

        private void resetFilterCriteria() {
            this.developerName = null;
            this.bindingObject = null;
        }

        private Boolean isBindingMatchByFilteringCriteria(di_Binding bind) {
            if (isExactMatch(bind)) {
                return true;
            }

            if (isDeveloperNameMatch(bind)) {
                return true;
            }

            if (isBindingObjectMatch(bind)) {
                return true;
            }

            return false;
        }

        private Boolean isExactMatch(di_Binding bind) {
            if (String.isBlank(this.developerName) || this.bindingObject == null) {
                return false;
            }

            return isDeveloperNameMatch(bind) && this.bindingObject == bind.BindingObject;
        }

        private Boolean isDeveloperNameMatch(di_Binding bind) {
            if (String.isBlank(this.developerName)) {
                return false;
            }

            return this.developerName.equalsIgnoreCase(bind.DeveloperName) ||
                   this.developerName.equalsIgnoreCase(di_NamespaceClass.CURRENTNAMESPACE + '.' + bind.DeveloperName);
        }

        private Boolean isBindingObjectMatch(di_Binding bind) {
            return this.bindingObject != null && bind.BindingObject == this.bindingObject;
        }

        private void loadBindings() {
            if (this.bindings != null) {
                return;
            }

            this.bindings = new List<di_Binding>();
            for (di_Module module : modules) {
                processModule(module);
            }
        }

        private void processModule(di_Module module) {
            module.configure();
            for(di_Binding bind : module.getBindings()) {
                if(isModuleBinding(bind)) {
                    processEmbeddedModule(bind);
                } else {
                    this.bindings.add(bind);
                }
            }
        }

        private Boolean isModuleBinding(di_Binding bind) {
            return bind.BindingType == di_Binding.BindingType.Module;
        }

        private void processEmbeddedModule(di_Binding bind) {
            di_Module embeddedModule = (di_Module) bind.getInstance();
            embeddedModule.configure();
            this.bindings.addAll(embeddedModule.getBindings());
        }

        public List<di_Binding> get() {
            List<di_Binding> matchedBindings = getCachedBindings();

            if (shouldLoadBindings(matchedBindings)) {
                loadAndFilterBindings(matchedBindings);
            }

            resetFilterCriteria();
            matchedBindings.sort();

            resetBindingsRequiredFlag();

            return matchedBindings;
        }

        private List<di_Binding> getCachedBindings() {
            return di_PlatformCache.getInstance().retrieveBindings(this.developerName, this.bindingObject);
        }

        private Boolean shouldLoadBindings(List<di_Binding> matchedBindings) {
            return (di_PlatformCache.isStoringBindingInPlatformCache() && bindingsAreRequired && matchedBindings.isEmpty()) ||
                   !di_PlatformCache.isStoringBindingInPlatformCache();
        }

        private void loadAndFilterBindings(List<di_Binding> matchedBindings) {
            loadBindings();

            for (di_Binding bind : bindings) {
                if (isBindingMatchByFilteringCriteria(bind)) {
                    matchedBindings.add(bind);
                }
            }
        }

        private void resetBindingsRequiredFlag() {
            this.bindingsAreRequired = true;
        }
    }

    public class BindingException extends Exception {}

    public enum BindingType { Apex, VisualforceComponent, LightningComponent, Flow, Module }

    public static di_Binding newInstance(
            BindingType bindType,
            String developerName,
            SObjectType bindingObject,
            Integer bindingSequence,
            Object to,
            Object bindingData) {

        Type implType = BINDING_IMPLS_BY_TYPE.get(bindType);

        if (implType != null) {
            return createBinding(implType, bindType, developerName, bindingObject, bindingSequence, to, bindingData);
        }

        throw new BindingException('Binding type ' + bindType + ' has no implementation.');
    }

    private static di_Binding createBinding(
        Type implType,
        BindingType bindType,
        String developerName,
        SObjectType bindingObject,
        Integer bindingSequence,
        Object to,
        Object bindingData) {

        di_Binding binding = (di_Binding) implType.newInstance();
        binding.BindingType = bindType;
        binding.DeveloperName = developerName;
        binding.BindingObject = bindingObject;
        binding.BindingSequence = bindingSequence;
        binding.To = to;
        binding.Data = bindingData;
        return binding;
    }

    private static final Map<BindingType, Type> BINDING_IMPLS_BY_TYPE =
        new Map<BindingType, Type> {
            BindingType.Apex => ApexBinding.class,
            BindingType.LightningComponent => LightningComponentBinding.class,
            BindingType.VisualforceComponent => VisualForceComponentBinding.class,
            BindingType.Flow => FlowBinding.class,
            BindingType.Module => ApexBinding.class
        };

    private class ApexBinding extends di_Binding {
        public override Object newInstance(Object params) {
            if (!(To instanceof String)) {
                return To;
            }

            String className = (String) To;
            Type toType = getTypeForClass(className);

            if (toType == null) {
                throw new BindingException('Apex binding ' + DeveloperName + ' implementation ' + To + ' does not exist');
            }

            return createInstance(toType, params);
        }

        private Type getTypeForClass(String className) {
            return NamespacePrefix == null ? Type.forName(className) : Type.forName(NamespacePrefix, className);
        }

        private Object createInstance(Type toType, Object params) {
            Object toObject = toType.newInstance();

            IsProvider = toObject instanceof Provider;
            if (IsProvider) {
                return ((Provider) toObject).newInstance(params);
            }

            if (params != null) {
                throw new BindingException('Apex binding ' + DeveloperName + ' implementation ' + toType.getName() + ' does not implement the Provider interface.');
            }

            return toObject;
        }
    }

    private class VisualForceComponentBinding extends di_Binding {
        public override Object newInstance(Object params) {
            if (!(To instanceof String)) {
                return To;
            }

            String className = (String) To;
            Type toType = getTypeForClass(className);

            if (toType == null) {
                throw new BindingException('Visualforce Component binding ' + DeveloperName + ' implementation ' + className + ' does not exist.');
            }

            return createInstance(toType, params);
        }

        private Type getTypeForClass(String className) {
            return NamespacePrefix == null ? Type.forName(className) : Type.forName(NamespacePrefix, className);
        }

        private Object createInstance(Type toType, Object params) {
            Object toObject = toType.newInstance();

            IsProvider = toObject instanceof Provider;
            if (IsProvider) {
                return ((Provider) toObject).newInstance(params);
            }

            throw new BindingException('Visualforce Component binding ' + DeveloperName + ' must point to a class implementing the Provider interface.');
        }
    }

    private class LightningComponentBinding extends di_Binding {
        public override Object newInstance(Object params) {
            return To;
        }
    }

    private class FlowBinding extends di_Binding {
        public override Object newInstance(Object params) {
            if (!(To instanceof String)) {
                return To;
            }

            String flowName = (String) To;
            Map<String, Object> flowParams = getFlowParameters(params);

            return new di_Flow(Flow.Interview.createInterview(flowName, flowParams));
        }

        private Map<String, Object> getFlowParameters(Object params) {
            if (params instanceof Map<String, Object>) {
                return (Map<String, Object>) params;
            }
            return new Map<String, Object>();
        }
    }
}
```

File `classes\di_BindingParam.cls`:
```apex
public with sharing class di_BindingParam {

    public static Map<String, Object> parameters { get; set; }

    @InvocableMethod(
        label = 'Get Value'
    )
    public static List<Response> invoke(List<Request> requests) {
        List<Response> responses = new List<Response>();

        for (Request req : requests) {
            Response res = processRequest(req);
            responses.add(res);
        }

        return responses;
    }

    private static Response processRequest(Request req) {
        Response res = new Response();

        if (parameters == null) {
            System.debug(LoggingLevel.WARN, 'BindingParam.parameters is null');
            return res;
        }

        Object value = parameters.get(req.paramName);
        if (value == null) {
            System.debug(LoggingLevel.WARN, 'BindingParam.parameters.get("' + req + '") is null');
            return res;
        }

        processValue(value, res);
        ensureSingleValues(res);
        ensureCollectionValues(res);

        System.debug('paramName=' + req);
        System.debug(res);

        return res;
    }

    private static void processValue(Object value, Response res) {
        if (value instanceof Decimal) {
            processDecimalValue((Decimal) value, res);
        } else if (value instanceof Decimal[]) {
            processDecimalArrayValue((Decimal[]) value, res);
        } else if (value instanceof String) {
            processStringValue((String) value, res);
        } else if (value instanceof String[]) {
            processStringArrayValue((String[]) value, res);
        } else if (value instanceof Boolean) {
            processBooleanValue((Boolean) value, res);
        } else if (value instanceof Boolean[]) {
            processBooleanArrayValue((Boolean[]) value, res);
        } else if (value instanceof Date) {
            processDateValue((Date) value, res);
        } else if (value instanceof Date[]) {
            processDateArrayValue((Date[]) value, res);
        } else if (value instanceof DateTime) {
            processDateTimeValue((DateTime) value, res);
        } else if (value instanceof DateTime[]) {
            processDateTimeArrayValue((DateTime[]) value, res);
        }
    }

    private static void processDecimalValue(Decimal value, Response res) {
        res.longValue = toLongValue(value);
        res.decimalValue = value;
        res.stringValue = toStringValue(value);
        res.booleanValue = toBooleanValue(value);
        res.dateValue = toDateValue(value);
        res.dateTimeValue = toDateTimeValue(value);
    }

    private static void processDecimalArrayValue(Decimal[] values, Response res) {
        res.decimalValues = values;
        for (Decimal value : values) {
            res.longValues.add(toLongValue(value));
            res.stringValues.add(toStringValue(value));
            res.booleanValues.add(toBooleanValue(value));
            res.dateValues.add(toDateValue(value));
            res.dateTimeValues.add(toDateTimeValue(value));
        }
    }

    private static void processStringValue(String value, Response res) {
        res.longValue = toLongValue(value);
        res.decimalValue = toDecimalValue(value);
        res.stringValue = value;
        res.booleanValue = toBooleanValue(value);
        res.dateValue = toDateValue(value);
        res.dateTimeValue = toDateTimeValue(value);
    }

    private static void processStringArrayValue(String[] values, Response res) {
        res.stringValues = values;
        for (String value : values) {
            res.longValues.add(toLongValue(value));
            res.decimalValues.add(toDecimalValue(value));
            res.booleanValues.add(toBooleanValue(value));
            res.dateValues.add(toDateValue(value));
            res.dateTimeValues.add(toDateTimeValue(value));
        }
    }

    private static void processBooleanValue(Boolean value, Response res) {
        res.longValue = toLongValue(value);
        res.decimalValue = toDecimalValue(value);
        res.stringValue = toStringValue(value);
        res.booleanValue = value;
        res.dateValue = toDateValue(value);
        res.dateTimeValue = toDateTimeValue(value);
    }

    private static void processBooleanArrayValue(Boolean[] values, Response res) {
        res.booleanValues = values;
        for (Boolean value : values) {
            res.longValues.add(toLongValue(value));
            res.decimalValues.add(toDecimalValue(value));
            res.stringValues.add(toStringValue(value));
            res.dateValues.add(toDateValue(value));
            res.dateTimeValues.add(toDateTimeValue(value));
        }
    }

    private static void processDateValue(Date value, Response res) {
        res.longValue = toLongValue(value);
        res.decimalValue = toDecimalValue(value);
        res.stringValue = toStringValue(value);
        res.booleanValue = toBooleanValue(value);
        res.dateValue = value;
        res.dateTimeValue = toDateTimeValue(value);
    }

    private static void processDateArrayValue(Date[] values, Response res) {
        res.dateValues = values;
        for (Date value : values) {
            res.longValues.add(toLongValue(value));
            res.decimalValues.add(toDecimalValue(value));
            res.stringValues.add(toStringValue(value));
            res.booleanValues.add(toBooleanValue(value));
            res.dateTimeValues.add(toDateTimeValue(value));
        }
    }

    private static void processDateTimeValue(DateTime value, Response res) {
        res.longValue = toLongValue(value);
        res.decimalValue = toDecimalValue(value);
        res.stringValue = toStringValue(value);
        res.booleanValue = toBooleanValue(value);
        res.dateValue = toDateValue(value);
        res.dateTimeValue = value;
    }

    private static void processDateTimeArrayValue(DateTime[] values, Response res) {
        res.dateTimeValues = values;
        for (DateTime value : values) {
            res.longValues.add(toLongValue(value));
            res.decimalValues.add(toDecimalValue(value));
            res.stringValues.add(toStringValue(value));
            res.booleanValues.add(toBooleanValue(value));
            res.dateValues.add(toDateValue(value));
        }
    }

    private static void ensureSingleValues(Response res) {
        if (res.longValue == null && !res.longValues.isEmpty()) {
            res.longValue = res.longValues[0];
        }
        if (res.decimalValue == null && !res.decimalValues.isEmpty()) {
            res.decimalValue = res.decimalValues[0];
        }
        if (res.stringValue == null && !res.stringValues.isEmpty()) {
            res.stringValue = res.stringValues[0];
        }
        if (res.booleanValue == null && !res.booleanValues.isEmpty()) {
            res.booleanValue = res.booleanValues[0];
        }
        if (res.dateValue == null && !res.dateValues.isEmpty()) {
            res.dateValue = res.dateValues[0];
        }
        if (res.dateTimeValue == null && !res.dateTimeValues.isEmpty()) {
            res.dateTimeValue = res.dateTimeValues[0];
        }
    }

    private static void ensureCollectionValues(Response res) {
        if (res.longValue != null && res.longValues.isEmpty()) {
            res.longValues.add(res.longValue);
        }
        if (res.decimalValue != null && res.decimalValues.isEmpty()) {
            res.decimalValues.add(res.decimalValue);
        }
        if (res.stringValue != null && res.stringValues.isEmpty()) {
            res.stringValues.add(res.stringValue);
        }
        if (res.booleanValue != null && res.booleanValues.isEmpty()) {
            res.booleanValues.add(res.booleanValue);
        }
        if (res.dateValue != null && res.dateValues.isEmpty()) {
            res.dateValues.add(res.dateValue);
        }
        if (res.dateTimeValue != null && res.dateTimeValues.isEmpty()) {
            res.dateTimeValues.add(res.dateTimeValue);
        }
    }

    private static Long toLongValue(Decimal value) {
        return (value == null ? null : value.longValue());
    }

    private static Long toLongValue(String value) {
        return ((value == null || !value.isNumeric()) ? null : Long.valueOf(value));
    }

    private static Long toLongValue(Boolean value) {
        return (value == null ? null : value ? 1 : 0);
    }

    private static Long toLongValue(Date value) {
        return (value == null ? null : toLongValue(
            DateTime.newInstance(value.year(), value.month(), value.day(), 0, 0, 0)
        ));
    }

    private static Long toLongValue(DateTime value) {
        return (value == null ? null : value.getTime());
    }

    private static Decimal toDecimalValue(String value) {
        return ((value == null || !value.isNumeric()) ? null : Decimal.valueOf(value));
    }

    private static Decimal toDecimalValue(Boolean value) {
        return (value == null ? null : value ? 1 : 0);
    }

    private static Decimal toDecimalValue(Date value) {
        return (value == null ? null : toDecimalValue(
            DateTime.newInstance(value.year(), value.month(), value.day(), 0, 0, 0)
        ));
    }

    private static Decimal toDecimalValue(DateTime value) {
        return (value == null ? null : value.getTime());
    }

    private static String toStringValue(Date value) {
        return (value == null ? null : String.valueOf(value));
    }

    private static String toStringValue(DateTime value) {
        return (value == null ? null : String.valueOf(value));
    }

    private static String toStringValue(Object value) {
        return (value == null ? null : String.valueOf(value));
    }

    private static Boolean toBooleanValue(Decimal value) {
        return (value == null ? false : (value > 0));
    }

    private static Boolean toBooleanValue(String value) {
        return (value == null ? false : Boolean.valueOf(value));
    }

    private static Boolean toBooleanValue(Date value) {
        return (value == null ? false : true);
    }

    private static Boolean toBooleanValue(DateTime value) {
        return (value == null ? false : true);
    }

    private static Date toDateValue(Decimal value) {
        return (value == null ? null : DateTime.newInstance(value.longValue()).date());
    }

    private static Date toDateValue(String value) {
        try {
            return (value == null ? null : Date.valueOf(value));
        } catch (Exception e) {
            return null;
        }
    }

    private static Date toDateValue(Boolean value) {
        return null;
    }

    private static Date toDateValue(DateTime value) {
        return (value == null ? null : value.date());
    }

    private static DateTime toDateTimeValue(Decimal value) {
        return (value == null ? null : DateTime.newInstance(value.longValue()));
    }

    private static DateTime toDateTimeValue(String value) {
        try {
            return (value == null ? null : DateTime.valueOf(value));
        } catch (Exception e) {
            return toDateValue(value);
        }
    }

    private static DateTime toDateTimeValue(Boolean value) {
        return null;
    }

    private static DateTime toDateTimeValue(Date value) {
        return (value == null ? null : DateTime.newInstance(value.year(), value.month(), value.day(), 0, 0, 0));
    }

    public class Request {
        @InvocableVariable(
            label = 'Parameter Name',
            required = true
        )
        public String paramName;
    }

    public class Response {
        @InvocableVariable(
            label = 'Number',
            description = 'Whole number (no decimals)'
        )
        public Long longValue;

        @InvocableVariable(
            label = 'Decimal',
            description = 'Number that may include decimal places'
        )
        public Decimal decimalValue;

        @InvocableVariable(
            label = 'Text',
            description = 'Text value'
        )
        public String stringValue;

        @InvocableVariable(
            label = 'Boolean',
            description = 'true/false'
        )
        public Boolean booleanValue;

        @InvocableVariable(
            label = 'Date'
        )
        public Date dateValue;

        @InvocableVariable(
            label = 'Date/Time'
        )
        public DateTime dateTimeValue;

        @InvocableVariable(
            label = 'Number Collection',
            description = 'Collection of whole numbers'
        )
        public Long[] longValues = new Long[] {};

        @InvocableVariable(
            label = 'Decimal Collection',
            description = 'Collection of numbers that may include decimal places'
        )
        public Decimal[] decimalValues = new Decimal[] {};

        @InvocableVariable(
            label = 'Text Collection',
            description = 'Collection of text values'
        )
        public String[] stringValues = new String[] {};

        @InvocableVariable(
            label = 'Boolean Collection',
            description = 'Collection of true/false values'
        )
        public Boolean[] booleanValues = new Boolean[] {};

        @InvocableVariable(
            label = 'Date Collection',
            description = 'Collection of date values'
        )
        public Date[] dateValues = new Date[] {};

        @InvocableVariable(
            label = 'Date/Time Collection',
            description = 'Collection of date/time values'
        )
        public DateTime[] dateTimeValues = new DateTime[] {};
    }
}
```

File `classes\di_Flow.cls`:
```apex
public class di_Flow {

    private Flow.Interview flow = null;
    @testVisible
    private Set<String> outputVarsNames;
    @testVisible
    private Set<String> outputVarsNamesRequired;

    public di_Flow(Flow.Interview flow) {
        this.flow = flow;
        init();
    }

    public di_Flow output(String variableName) {
        outputVarsNames.add(variableName);
        return this;
    }

    public di_Flow required(String variableName) {
        output(variableName);
        outputVarsNamesRequired.add(variableName);
        return this;
    }

    public Map<String, Object> run() {
        try {
            flow.start();
            return collectOutputVariables();
        } finally {
            init();
        }
    }

    private Map<String, Object> collectOutputVariables() {
        Map<String, Object> outputVars = new Map<String, Object>();

        for(String outputVar : outputVarsNames) {
            processOutputVariable(outputVar, outputVars);
        }

        return outputVars;
    }

    private void processOutputVariable(String outputVar, Map<String, Object> outputVars) {
        Object outputVarValue = flow.getVariableValue(outputVar);

        if (outputVarValue != null) {
            outputVars.put(outputVar, outputVarValue);
        } else if (isRequiredVariable(outputVar)) {
            throw new FlowException('Output variable ' + outputVar + ' expected but not returned from Flow');
        }
    }

    private Boolean isRequiredVariable(String outputVar) {
        return outputVarsNamesRequired.contains(outputVar);
    }

    public Object returning(String outputVariableName) {
        return required(outputVariableName).run().get(outputVariableName);
    }

    private void init() {
        outputVarsNames = new Set<String>();
        outputVarsNamesRequired = new Set<String>();
    }

    public class FlowException extends Exception {}
}
```

File `classes\di_Injector.cls`:
```apex
public class di_Injector {
    @testVisible
    private static List<di_BindingConfigWrapper> mock_BindingConfigurationWrappersOuter = null;

    public static final di_Injector Org =
        new di_Injector(
            new List<di_Module> {
        new CustomMetadataModule()
    });

    @TestVisible
    public di_Binding.Resolver Bindings {get; private set;}

    public di_Injector(di_Module module) {
        this(new List<di_Module> { module });
    }

    public di_Injector(List<di_Module> modules) {
        Bindings = new di_Binding.Resolver(modules);
    }

    public Object getInstance(Type developerNameByType) {
        return getInstance(developerNameByType?.getName()?.toLowerCase(), null);
    }

    public Object getInstance(Type developerNameByType, Object params) {
        return getInstance(developerNameByType?.getName()?.toLowerCase(), params);
    }

    public Object getInstance(String developerName) {
        return getInstance(developerName, null);
    }

    public Object getInstance(String developerName, Object params) {
        if (String.isBlank(developerName)) {
            throw new InjectorException('Request for Binding cannot take "developerName" parameter of null');
        }

        List<di_Binding> bindingsFound = getBindingsByName(developerName);
        validateBindingsFound(bindingsFound, developerName);

        return bindingsFound[0].getInstance(params);
    }

    private List<di_Binding> getBindingsByName(String developerName) {
        return this.Bindings.byName(developerName.toLowerCase().trim()).get();
    }

    private void validateBindingsFound(List<di_Binding> bindingsFound, String developerName) {
        if (bindingsFound == null || bindingsFound.isEmpty()) {
            throw new InjectorException('Binding for "' + developerName + '" not found');
        }
    }

    public Object getInstance(Type developerNameByType, Schema.SObjectType bindingSObjectType) {
        return getInstance(developerNameByType, bindingSObjectType, null);
    }

    public Object getInstance(Type developerNameByType, Schema.SObjectType bindingSObjectType, Object params) {
        return getInstance(developerNameByType == null ? null : developerNameByType.getName().toLowerCase(), bindingSObjectType, params);
    }

    public Object getInstance(String developerName, Schema.SObjectType bindingSObjectType, Object params) {
        validateDeveloperName(developerName);
        validateBindingSObjectType(bindingSObjectType);

        List<di_Binding> bindingsFound = getBindingsByNameAndSObjectType(developerName, bindingSObjectType);
        validateBindingsFound(bindingsFound, developerName, bindingSObjectType);

        return bindingsFound[0].getInstance(params);
    }

    private void validateDeveloperName(String developerName) {
        if (String.isBlank(developerName)) {
            throw new InjectorException('Request for Binding cannot take "developerName" parameter of null');
        }
    }

    private void validateBindingSObjectType(Schema.SObjectType bindingSObjectType) {
        if (bindingSObjectType == null) {
            throw new InjectorException('Request for Binding cannot take "bindingSObjectType" parameter of null');
        }
    }

    private List<di_Binding> getBindingsByNameAndSObjectType(String developerName, Schema.SObjectType bindingSObjectType) {
        return this.Bindings.bySObject(bindingSObjectType)
            .byName(developerName.toLowerCase().trim())
            .get();
    }

    private void validateBindingsFound(List<di_Binding> bindingsFound, String developerName, Schema.SObjectType bindingSObjectType) {
        if (bindingsFound == null || bindingsFound.isEmpty() || bindingsFound[0] == null) {
            throw new InjectorException('Binding for "' + developerName + '" and SObjectType "' + bindingSObjectType + '" not found');
        }
    }

    @testVisible
    private class CustomMetadataModule extends di_Module {

        private string bindingObjectApiName = null;

        @testVisible
        private List<di_BindingConfigWrapper> getDIBinding(){
            List<di_BindingConfigWrapper> recordList = new List<di_BindingConfigWrapper>();

            if(di_Injector.mock_BindingConfigurationWrappersOuter != null) {
                recordList = di_Injector.mock_BindingConfigurationWrappersOuter;
            } else {
                List<di_Binding__mdt> bindingMDTRec = [SELECT QualifiedAPIName
                                                            , DeveloperName
                                                            , BindingName__c
                                                            , NamespacePrefix
                                                            , Type__c
                                                            , To__c
                                                            , BindingObject__c
                                                            , BindingObject__r.QualifiedApiName
                                                            , BindingObjectAlternate__c
                                                            , BindingSequence__c
                                                         FROM di_Binding__mdt];
                for(di_Binding__mdt records :bindingMDTRec) {
                    recordList.add(new di_BindingConfigWrapper(records));
                }
            }
            return recordList;
        }

        public override void configure() {
            for(di_BindingConfigWrapper bindingConfig : getDIBinding()) {
                configureBinding(bindingConfig);
            }
        }

        private void configureBinding(di_BindingConfigWrapper bindingConfig) {
            bind(bindingConfig.DeveloperName);
            type(bindingConfig.Type);

            if (hasBindingObject(bindingConfig)) {
                configureBindingObject(bindingConfig);
            }

            if (hasBindingSequence(bindingConfig)) {
                sequence(Integer.valueOf(bindingConfig.BindingSequence));
            }

            data(bindingConfig);
            to(bindingConfig.To);
        }

        private Boolean hasBindingObject(di_BindingConfigWrapper bindingConfig) {
            return String.isNotBlank(bindingConfig.BindingObject) ||
                   String.isNotBlank(bindingConfig.BindingObjectAlternate);
        }

        private void configureBindingObject(di_BindingConfigWrapper bindingConfig) {
            bindingObjectApiName = getBindingObjectApiName(bindingConfig);
            Schema.DescribeSobjectResult[] results = Schema.describeSObjects(new String[] { bindingObjectApiName });

            if (results.size() != 1) {
                throw new InjectorException('Failed to find SObject ' + bindingObjectApiName + ' referenced by binding ' + bindingConfig.DeveloperName);
            }

            bind(results[0].getSObjectType());
        }

        private String getBindingObjectApiName(di_BindingConfigWrapper bindingConfig) {
            if (String.isNotBlank(bindingConfig.BindingObject)) {
                return bindingConfig.bindingObjectQualifiedApiName.toLowerCase().trim();
            }
            return bindingConfig.BindingObjectAlternate.toLowerCase().trim();
        }

        private Boolean hasBindingSequence(di_BindingConfigWrapper bindingConfig) {
            return bindingConfig.BindingSequence != null;
        }
    }

    public class InjectorException extends Exception {}
}
```

File `classes\di_InjectorComponentController.cls`:
```apex
public with sharing class di_InjectorComponentController {

    public String BindingNameValue {set; get;}

    public String BindingIdValue {set; get;}
    public Object ParametersValue {set; get;}

    public ApexPages.Component getInject() {
        di_Binding bindingInfo = getBinding(BindingNameValue);
        return createComponent(bindingInfo);
    }

    private ApexPages.Component createComponent(di_Binding bindingInfo) {
        switch on bindingInfo.BindingType {
            when Flow {
                return (ApexPages.Component) getInjectorFlowProxyInstance((String) bindingInfo.To, ParametersValue);
            }
            when else {
                return (ApexPages.Component) di_Injector.Org.getInstance(BindingNameValue, ParametersValue);
            }
        }
    }

    public static di_Binding getBinding(String bindingName) {
        return di_Injector.Org.Bindings.byName(bindingName).get()[0];
    }

    @testVisible
    private Object getInjectorFlowProxyInstance(String flowName, Object params) {
        return new Component.di_injectorFlowProxy(
            flowName = flowName,
            inputVariables = params
        );
    }
}
```

File `classes\di_InjectorComponentFlowProxyController.cls`:
```apex
public with sharing class di_InjectorComponentFlowProxyController {

    public String FlowNameValue { get; set; }

    public Object InputVariablesValue { get; set; }

    public Component.Flow.Interview getInject() {
        Component.Flow.Interview interview = new Component.Flow.Interview();
        interview.name = FlowNameValue;

        processInputVariables();

        return interview;
    }

    private void processInputVariables() {
        if (InputVariablesValue instanceof Map<Object, Object>) {
            processObjectKeyMap();
        } else if (InputVariablesValue instanceof Map<String, Object>) {
            di_BindingParam.parameters = (Map<String, Object>) InputVariablesValue;
        }
    }

    private void processObjectKeyMap() {
        Map<Object, Object> oldMap = (Map<Object, Object>) InputVariablesValue;
        Map<String, Object> newMap = new Map<String, Object>();

        for (Object key : oldMap.keySet()) {
            newMap.put(String.valueOf(key), oldMap.get(key));
        }

        di_BindingParam.parameters = newMap;
    }
}
```

File `classes\di_Module.cls`:
```apex
public virtual class di_Module {

    private List<di_Binding> bindings = new List<di_Binding>();
    private di_Binding.BindingType bindingType;
    private String developerName;
    private SObjectType bindingObject;
    private Integer bindingSequence;
    private Object to;
    private Object bindingData;

    public di_Module() {
        init();
    }

    public virtual void configure() { }

    public di_Module type(String value) {
        List<di_Binding.BindingType> bindEnumValues = di_Binding.BindingType.values();

        for(di_Binding.BindingType bindEnumValue : bindEnumValues) {
            if(bindEnumValue.name().equals(value)) {
                bindingType = bindEnumValue;
                return this;
            }
        }

        throw new ModuleException('Binding type ' + value + ' is not valid.');
    }

    public di_Module type(di_Binding.BindingType value) {
        bindingType = value;
        return this;
    }

    public di_Module apex() {
        bindingType = di_Binding.BindingType.Apex;
        return this;
    }

    public di_Module lightningComponent() {
        bindingType = di_Binding.BindingType.LightningComponent;
        return this;
    }

    public di_Module visualforceComponent() {
        bindingType = di_Binding.BindingType.VisualforceComponent;
        return this;
    }

    public di_Module flow() {
        bindingType = di_Binding.BindingType.Flow;
        return this;
    }

    public di_Module module() {
        bindingType = di_Binding.BindingType.Module;
        return this;
    }

    public di_Module bind(Type bindingType) {
        developerName = bindingType.getName();
        return this;
    }

    public di_Module bind(SObjectType sObjectType) {
        bindingObject = sObjectType;
        return this;
    }

    public di_Module bind(String bindingName) {
        developerName = bindingName;
        return this;
    }

    public di_Module sequence(Integer sequence) {
        bindingSequence = sequence;
        return this;
    }

    public di_Module data(Object data) {
        bindingData = data;
        return this;
    }

    public di_Module to(String bindingTo) {
        return toObject(bindingTo);
    }

    public di_Module to(Type bindingTo) {
        return toObject(bindingTo.getName());
    }

    public di_Module toObject(Object to) {
        this.to = to;

        if(to instanceof di_Flow) {
            return flow().addBinding();
        }

        return addBinding();
    }

    public List<di_Binding> getBindings() {
        return this.bindings;
    }

    private di_Module addBinding() {
        di_Binding newBinding = createBinding();

        bindings.add(newBinding);
        di_PlatformCache.getInstance().addBindingToPlatformCache(newBinding);

        init();
        return this;
    }

    private di_Binding createBinding() {
        return di_Binding.newInstance(
            bindingType,
            developerName,
            bindingObject,
            bindingSequence,
            to,
            bindingData
        );
    }

    private void init() {
        bindingType = di_Binding.BindingType.Apex;
        developerName = null;
        bindingObject = null;
        bindingSequence = null;
        to = null;
    }

    public class ModuleException extends Exception {}
}
```

File `classes\di_PlatformCache.cls`:
```apex
public with sharing class di_PlatformCache {

    public static final Integer NUM_OF_SECS_IN24HR = 86400;

    @TestVisible
    private static final String BINDING_KEY = 'bindingKeyIndex';
    @TestVisible
    private static di_PlatformCache instance;
    @TestVisible
    private Map<String, Map<Schema.SObjectType, Set<String>>> cacheKeyIndexMap = new Map<String, Map<Schema.SObjectType, Set<String>>>();
    @TestVisible
    private static Map<String, String> generatedKeyNames = new Map<String, String>();

    @TestVisible
    private static Boolean DEBUGGING = false;

    private di_PlatformCache() {
    }

    public static di_PlatformCache getInstance() {
        if (instance == null) {
            instance = new di_PlatformCache();
        }

        return instance;
    }

    public static Boolean isStoringBindingInPlatformCache() {
        return getConfig().UsePlatformCacheToStoreBindings__c == null ? false :
               (getConfig().UsePlatformCacheToStoreBindings__c && getPartition() != null);
    }

    public Map<String, Map<Schema.SObjectType, Set<String>>> getCacheKeyIndexMap() {
        if (cacheKeyIndexMap.isEmpty()) {
            loadCacheKeyIndexMap();
        }

        return cacheKeyIndexMap;
    }

    private void loadCacheKeyIndexMap() {
        try {
            Cache.OrgPartition orgPartition = getPartition();
            if (orgPartition != null) {
                cacheKeyIndexMap = (Map<String, Map<Schema.SObjectType, Set<String>>>) orgPartition.get(getKeyIndexName());
            }
        } catch (Cache.Org.OrgCacheException ex) {
            cacheKeyIndexMap = null;
        }

        if (cacheKeyIndexMap == null) {
            cacheKeyIndexMap = new Map<String, Map<Schema.SObjectType, Set<String>>>();
        }
    }

    public Boolean addBindingToPlatformCache(di_Binding binding) {
        if (!isStoringBindingInPlatformCache()) {
            return false;
        }

        Cache.OrgPartition orgPartition = getPartition();
        if (orgPartition == null) {
            return false;
        }

        String theKeyName = getKeyName(binding);
        List<di_Binding> workingBindings = getExistingBindings(orgPartition, theKeyName);

        workingBindings.add(binding);
        log('Adding binding for hash => ' + theKeyName + ' && developerName => ' + binding.developerName + ' && object => ' + binding.bindingObject);

        try {
            orgPartition.put(theKeyName, workingBindings, getPartitionTTL(), Cache.Visibility.ALL, false);
        } catch (cache.Org.OrgCacheException oce) {
            log(oce);
        }

        addBindingToKeyIndex(binding);
        return true;
    }

    private List<di_Binding> getExistingBindings(Cache.OrgPartition orgPartition, String theKeyName) {
        List<di_Binding> workingBindings = new List<di_Binding>();

        if (orgPartition.contains(theKeyName)) {
            workingBindings.addAll((List<di_Binding>) orgPartition.get(theKeyName));
        }

        return workingBindings;
    }

    public list<di_Binding> retrieveBindings(String developerName, Schema.SObjectType bindingSObjectType) {
        list<di_Binding> bindings = new list<di_Binding>();

        if (!shouldRetrieveFromCache(developerName, bindingSObjectType)) {
            return bindings;
        }

        log('Retrieving from Cache Key => ' + developerName + ' && Cache Key Index => ' + bindingSObjectType);

        Cache.OrgPartition orgPartition = getPartition();
        Map<Schema.SObjectType, Set<String>> keyIndexBySObjectTypeMap = getCacheKeyIndexMap().get(developerName.toLowerCase().trim());

        if (keyIndexBySObjectTypeMap == null || orgPartition == null) {
            return bindings;
        }

        Set<String> cacheKeys = keyIndexBySObjectTypeMap.get(bindingSObjectType);
        if (cacheKeys == null) {
            return bindings;
        }

        return getBindingsFromCache(orgPartition, cacheKeys);
    }

    private Boolean shouldRetrieveFromCache(String developerName, Schema.SObjectType bindingSObjectType) {
        return isStoringBindingInPlatformCache() &&
               string.isNotBlank(developerName) &&
               bindingSObjectType != null;
    }

    private list<di_Binding> getBindingsFromCache(Cache.OrgPartition orgPartition, Set<String> cacheKeys) {
        list<di_Binding> bindings = new list<di_Binding>();
        Object cachedObject = null;

        for (String cacheKey : cacheKeys) {
            cachedObject = orgPartition.get(cacheKey);
            if (cachedObject != null) {
                bindings.addAll((List<di_Binding>) cachedObject);
            }
        }

        return bindings;
    }

    public static void clearCachedBindings() {
        Set<String> keys = getPartitionKeys();

        if (keys == null) {
            return;
        }

        String partitionKey = getPartitionName();
        Cache.OrgPartition partition = getPartition();

        for (String key : partition.getKeys()) {
            try {
                partition.remove(key);
            } catch (Exception ex) {
                log('XX]> Unable to remove Platform Cache partition [' + partitionKey + '] key [' + key + ']');
            }
        }
    }

    public static Set<String> getPartitionKeys() {
        Set<String> keys = null;
        Cache.OrgPartition partition = getPartition();

        if (partition != null) {
            keys = partition.getKeys();
        }

        return keys;
    }

    @TestVisible
    private static di_Configurations__c getConfig() {
        di_Configurations__c config = di_Configurations__c.getInstance();

        if (config == null) {
            config = createNewConfig();
        }

        return config;
    }

    private static di_Configurations__c createNewConfig() {
        di_Configurations__c config = new di_Configurations__c();
        config.SetupOwnerId = ConnectApi.Organization.getSettings().orgId;

        if (di_Configurations__c.SObjectType.getDescribe().isCreateable()) {
            insert config;
        }

        return config;
    }

    @TestVisible
    private static String getPartitionName() {
        return getConfig().OrgCachePartitionName__c;
    }

    @TestVisible
    private Integer getPartitionTTL() {
        return NUM_OF_SECS_IN24HR;
    }

    @TestVisible
    private static Cache.OrgPartition getPartition() {
        Cache.OrgPartition result = null;

        try {
            result = Cache.Org.getPartition(getPartitionName());
        } catch (Exception excp) {
            log('ERROR: Is there Cache? Is the Cache Partition enabled : Exception:' + excp);
        }

        return result;
    }

    @TestVisible
    private boolean pushCacheKeyIndexMapToCache() {
        Cache.OrgPartition orgPartition = getPartition();

        if (orgPartition != null) {
            orgPartition.put(getKeyIndexName(), this.cacheKeyIndexMap, getPartitionTTL(), Cache.Visibility.ALL, false);
        }

        return orgPartition != null;
    }

    @TestVisible
    private void addBindingToKeyIndex(di_Binding binding) {
        if (binding == null) {
            return;
        }

        String workingDeveloperName = binding.developerName.toLowerCase().trim();

        initializeKeyIndexIfNeeded(workingDeveloperName);
        initializeSObjectTypeIndexIfNeeded(workingDeveloperName, binding.bindingObject);

        getCacheKeyIndexMap().get(workingDeveloperName).get(binding.bindingObject).add(getKeyName(binding));
        pushCacheKeyIndexMapToCache();
    }

    private void initializeKeyIndexIfNeeded(String workingDeveloperName) {
        if (!getCacheKeyIndexMap().containsKey(workingDeveloperName)) {
            getCacheKeyIndexMap().put(workingDeveloperName, new Map<Schema.SObjectType, Set<String>>());
        }
    }

    private void initializeSObjectTypeIndexIfNeeded(String workingDeveloperName, Schema.SObjectType bindingObject) {
        if (!getCacheKeyIndexMap().get(workingDeveloperName).containsKey(bindingObject)) {
            getCacheKeyIndexMap().get(workingDeveloperName).put(bindingObject, new Set<String>());
        }
    }

    @TestVisible
    private String constructKeyName(Schema.SObjectType bindingSObjectType, String developerName) {
        if (String.isBlank(developerName)) {
            return null;
        }

        String key = buildKeyString(bindingSObjectType, developerName);

        if (generatedKeyNames.containsKey(key)) {
            return generatedKeyNames.get(key);
        }

        String hash = generateHash(key);
        log('Creating Hash For => ' + developerName + ' && ' + bindingSObjectType + ' := ' + hash);

        generatedKeyNames.put(key, hash);
        return hash;
    }

    private String buildKeyString(Schema.SObjectType bindingSObjectType, String developerName) {
        String objectName = (bindingSObjectType != null) ? bindingSObjectType.getDescribe().getName().toLowerCase().replaceAll('__','') : '';
        String namePart = String.isBlank(developerName) ? '' : developerName.toLowerCase().trim();

        return objectName + namePart;
    }

    private String generateHash(String key) {
        return String.valueOf(Math.abs((key).hashcode()));
    }

    @TestVisible
    private String getKeyName(String developerName, Schema.SObjectType bindingSObjectType) {
        return constructKeyName(bindingSObjectType, developerName);
    }

    @TestVisible
    private String getKeyName(di_Binding binding) {
        return constructKeyName(binding.bindingObject, binding.developerName);
    }

    @TestVisible
    private String getKeyIndexName() {
        return di_PlatformCache.BINDING_KEY;
    }

    @TestVisible
    private static Boolean log(Exception excp) {
        Boolean before = DEBUGGING;
        Boolean result;

        DEBUGGING = true;
        result = log('Exception: ' + excp.getMessage());
        DEBUGGING = before;

        return result;
    }

    @TestVisible
    private static Boolean log(String message) {
        Boolean doLog = DEBUGGING && string.isNotBlank(message);

        if (doLog) {
            system.debug('+++ di_PlatformCache.message: ' + message);
        }

        return doLog;
    }
}
```

The refactoring focuses on:
1. Breaking down complex methods into smaller, focused methods with clear responsibilities
2. Reducing nested conditionals and early returns
3. Extracting helper methods for repeated operations
4. Improving code organization and readability
5. Maintaining the exact same behavior while reducing cognitive complexity

Each file has been refactored to make the code more maintainable and easier to understand while preserving all functionality.