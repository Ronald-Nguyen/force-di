I'll refactor the code to reduce cognitive complexity while preserving behavior. Here are the refactored files:

File `classes\di_Binding.cls`:
```apex
public abstract class di_Binding implements Comparable {

    public BindingType BindingType {get; private set;}

    @AuraEnabled
    public String BindingTypeAsString {get { return BindingType.name();} }

    @AuraEnabled
    public String NamespacePrefix {get;private set;}

    @AuraEnabled
    public String DeveloperName {get;private set;}

    @AuraEnabled
    public SObjectType BindingObject {get;private set;}

    @AuraEnabled
    public Integer BindingSequence {get;private set;}

    @AuraEnabled
    public Object To {get;private set;}

    @AuraEnabled
    public Object Data {get;private set;}

    private Boolean IsProvider = false;
    private Object Injected = null;

    public Object getInstance() {
        return getInstance(null, false);
    }

    public Object getInstance(Object params) {
        return getInstance(params, false);
    }

    public Object getInstance(Object params, Boolean newInstance) {
        if(IsProvider) {
            return newInstance(params);
        }

        if(newInstance) {
            return newInstance(params);
        }

        if(Injected == null) {
            Injected = newInstance(params);
        }

        return Injected;
    }

    public abstract Object newInstance(Object params);

    public Integer compareTo(Object compareTo) {
        di_Binding binding = (di_Binding) compareTo;
        return this.toString().compareTo(binding.toString());
    }

    public override String toString() {
        String hashValue = getBaseHashValue();

        if(BindingSequence != null) {
            hashValue += '#' + String.valueOf(BindingSequence).leftPad(4,'0');
        }

        return hashValue;
    }

    private String getBaseHashValue() {
        return (BindingObject != null) ?
            BindingObject.getDescribe().getName() :
            DeveloperName;
    }

    public interface Provider {
        Object newInstance(Object params);
    }

    public class Resolver {

        private String developerName;
        private SObjectType bindingObject;
        private boolean bindingsAreRequired = true;

        private List<di_Module> modules = null;

        private List<di_Binding> bindings = null;

        public Resolver(List<di_Module> modules) {
            this.modules = modules;
        }

        public Resolver set(di_Module module) {
            modules.clear();
            modules.add(module);

            bindings = null;
            return this;
        }

        public Resolver add(di_Module module) {
            modules.add(module);

            bindings = null;
            return this;
        }

        public Resolver byName(String developerName) {
            this.developerName = developerName;
            return this;
        }

        public Resolver bySObject(SObjectType bindingObject) {
            this.bindingObject = bindingObject;
            return this;
        }

        public Resolver emptyBindingsAllowed() {
            bindingsAreRequired = false;
            return this;
        }

        public Resolver replaceBindingWith(Object mockType) {
            loadBindings();

            for (Integer currentBindingsIndex = 0; currentBindingsIndex < this.bindings.size(); currentBindingsIndex++) {
                if (isBindingMatchByFilteringCriteria(this.bindings[currentBindingsIndex])) {
                    this.bindings[currentBindingsIndex] = di_Binding.newInstance(
                        di_Binding.BindingType.Apex,
                        this.developerName,
                        this.bindingObject,
                        null,
                        mockType,
                        null
                    );
                    break;
                }
            }

            resetSearchCriteria();
            return this;
        }

        private void resetSearchCriteria() {
            this.developerName = null;
            this.bindingObject = null;
        }

        private Boolean isBindingMatchByFilteringCriteria(di_Binding bind) {
            if (hasBothSearchCriteria()) {
                return isExactMatch(bind);
            }

            return isPartialMatch(bind);
        }

        private Boolean hasBothSearchCriteria() {
            return String.isNotBlank(this.developerName) && this.bindingObject != null;
        }

        private Boolean isExactMatch(di_Binding bind) {
            return (isDeveloperNameMatch(bind) || isNamespacedDeveloperNameMatch(bind)) &&
                   this.bindingObject == bind.BindingObject;
        }

        private Boolean isPartialMatch(di_Binding bind) {
            return isDeveloperNameMatch(bind) ||
                   isNamespacedDeveloperNameMatch(bind) ||
                   isBindingObjectMatch(bind);
        }

        private Boolean isDeveloperNameMatch(di_Binding bind) {
            return String.isNotBlank(this.developerName) &&
                   this.developerName.equalsIgnoreCase(bind.DeveloperName);
        }

        private Boolean isNamespacedDeveloperNameMatch(di_Binding bind) {
            return String.isNotBlank(this.developerName) &&
                   this.developerName.equalsIgnoreCase(di_NamespaceClass.CURRENTNAMESPACE + '.' + bind.DeveloperName);
        }

        private Boolean isBindingObjectMatch(di_Binding bind) {
            return this.bindingObject != null && bind.BindingObject == this.bindingObject;
        }

        private void loadBindings() {
            if (this.bindings == null) {
                this.bindings = new List<di_Binding>();
                processModules();
            }
        }

        private void processModules() {
            for (di_Module module : modules) {
                module.configure();
                processModuleBindings(module);
            }
        }

        private void processModuleBindings(di_Module module) {
            for(di_Binding bind : module.getBindings()) {
                if(isModuleBinding(bind)) {
                    processEmbeddedModule(bind);
                } else {
                    this.bindings.add(bind);
                }
            }
        }

        private Boolean isModuleBinding(di_Binding bind) {
            return bind.BindingType == di_Binding.BindingType.Module;
        }

        private void processEmbeddedModule(di_Binding bind) {
            di_Module embeddedModule = (di_Module) bind.getInstance();
            embeddedModule.configure();
            this.bindings.addAll(embeddedModule.getBindings());
        }

        public List<di_Binding> get() {
            List<di_Binding> matchedBindings = getCachedBindings();

            if (shouldLoadBindingsFromCache(matchedBindings)) {
                loadBindingsFromCache(matchedBindings);
            }

            if (shouldLoadBindingsFromSource(matchedBindings)) {
                loadBindingsFromSource(matchedBindings);
            }

            resetSearchCriteria();
            matchedBindings.sort();

            this.bindingsAreRequired = true;

            return matchedBindings;
        }

        private List<di_Binding> getCachedBindings() {
            return di_PlatformCache.getInstance().retrieveBindings(this.developerName, this.bindingObject);
        }

        private Boolean shouldLoadBindingsFromCache(List<di_Binding> matchedBindings) {
            return di_PlatformCache.isStoringBindingInPlatformCache() &&
                   bindingsAreRequired &&
                   matchedBindings.isEmpty();
        }

        private void loadBindingsFromCache(List<di_Binding> matchedBindings) {
            loadBindings();

            for (di_Binding bind : bindings) {
                if (isBindingMatchByFilteringCriteria(bind)) {
                    matchedBindings.add(bind);
                }
            }
        }

        private Boolean shouldLoadBindingsFromSource(List<di_Binding> matchedBindings) {
            return !di_PlatformCache.isStoringBindingInPlatformCache() ||
                   !bindingsAreRequired ||
                   !matchedBindings.isEmpty();
        }

        private void loadBindingsFromSource(List<di_Binding> matchedBindings) {
            loadBindings();

            for (di_Binding bind : bindings) {
                if (isBindingMatchByFilteringCriteria(bind)) {
                    matchedBindings.add(bind);
                }
            }
        }
    }

    public class BindingException extends Exception {}

    public enum BindingType { Apex, VisualforceComponent, LightningComponent, Flow, Module }

    public static di_Binding newInstance(
            BindingType bindType,
            String developerName,
            SObjectType bindingObject,
            Integer bindingSequence,
            Object to,
            Object bindingData) {

        Type implType = BINDING_IMPLS_BY_TYPE.get(bindType);

        if (implType != null) {
            return createBindingInstance(
                implType,
                bindType,
                developerName,
                bindingObject,
                bindingSequence,
                to,
                bindingData
            );
        }

        throw new BindingException('Binding type ' + bindType + ' has no implementation.');
    }

    private static di_Binding createBindingInstance(
            Type implType,
            BindingType bindType,
            String developerName,
            SObjectType bindingObject,
            Integer bindingSequence,
            Object to,
            Object bindingData) {

        di_Binding binding = (di_Binding) implType.newInstance();
        binding.BindingType = bindType;
        binding.DeveloperName = developerName;
        binding.BindingObject = bindingObject;
        binding.BindingSequence = bindingSequence;
        binding.To = to;
        binding.Data = bindingData;
        return binding;
    }

    private static final Map<BindingType, Type> BINDING_IMPLS_BY_TYPE =
        new Map<BindingType, Type> {
            BindingType.Apex => ApexBinding.class,
            BindingType.LightningComponent => LightningComponentBinding.class,
            BindingType.VisualforceComponent => VisualForceComponentBinding.class,
            BindingType.Flow => FlowBinding.class,
            BindingType.Module => ApexBinding.class
        };

    private class ApexBinding extends di_Binding {
        public override Object newInstance(Object params) {
            if (To instanceof String) {
                return createInstanceFromString((String) To, params);
            }

            return To;
        }

        private Object createInstanceFromString(String className, Object params) {
            Type toType = getTypeForClassName(className);

            if (toType == null) {
                throw new BindingException('Apex binding ' + DeveloperName + ' implementation ' + To + ' does not exist');
            }

            Object toObject = toType.newInstance();
            IsProvider = toObject instanceof Provider;

            if (IsProvider) {
                return ((Provider) toObject).newInstance(params);
            }

            if (params != null) {
                throw new BindingException('Apex binding ' + DeveloperName + ' implementation ' + className + ' does not implement the Provider interface.');
            }

            return toObject;
        }

        private Type getTypeForClassName(String className) {
            return NamespacePrefix == null ?
                Type.forName(className) :
                Type.forName(NamespacePrefix, className);
        }
    }

    private class VisualForceComponentBinding extends di_Binding {
        public override Object newInstance(Object params) {
            if (To instanceof String) {
                return createInstanceFromString((String) To, params);
            }

            return To;
        }

        private Object createInstanceFromString(String className, Object params) {
            Type toType = getTypeForClassName(className);

            if (toType == null) {
                throw new BindingException('Visualforce Component binding ' + DeveloperName + ' implementation ' + className + ' does not exist.');
            }

            Object toObject = toType.newInstance();
            IsProvider = toObject instanceof Provider;

            if (IsProvider) {
                return ((Provider) toObject).newInstance(params);
            }

            throw new BindingException('Visualforce Component binding ' + DeveloperName + ' must point to a class implementing the Provider interface.');
        }

        private Type getTypeForClassName(String className) {
            return NamespacePrefix == null ?
                Type.forName(className) :
                Type.forName(NamespacePrefix, className);
        }
    }

    private class LightningComponentBinding extends di_Binding {
        public override Object newInstance(Object params) {
            return To;
        }
    }

    private class FlowBinding extends di_Binding {
        public override Object newInstance(Object params) {
            if (To instanceof String) {
                return createFlowInstance((String) To, params);
            }

            return To;
        }

        private Object createFlowInstance(String flowName, Object params) {
            if (params instanceof Map<String, Object>) {
                return new di_Flow(Flow.Interview.createInterview(flowName, (Map<String, Object>) params));
            }

            return new di_Flow(Flow.Interview.createInterview(flowName, new Map<String, Object>()));
        }
    }
}
```

File `classes\di_Injector.cls`:
```apex
public class di_Injector {
    @testVisible
    private static List<di_BindingConfigWrapper> mock_BindingConfigurationWrappersOuter = null;

    public static final di_Injector Org =
        new di_Injector(
            new List<di_Module> {
        new CustomMetadataModule()
    });

    @TestVisible
    public di_Binding.Resolver Bindings {get; private set;}

    public di_Injector(di_Module module) {
        this(new List<di_Module> { module });
    }

    public di_Injector(List<di_Module> modules) {
        Bindings = new di_Binding.Resolver(modules);
    }

    public Object getInstance(Type developerNameByType) {
        return getInstance(developerNameByType?.getName()?.toLowerCase(), null);
    }

    public Object getInstance(Type developerNameByType, Object params) {
        return getInstance(developerNameByType?.getName()?.toLowerCase(), params);
    }

    public Object getInstance(String developerName) {
        return getInstance(developerName, null);
    }

    public Object getInstance(String developerName, Object params) {
        if (String.isBlank(developerName)) {
            throw new InjectorException('Request for Binding cannot take "developerName" parameter of null');
        }

        List<di_Binding> bindingsFound = getBindingsByName(developerName);

        if (bindingsFound == null || bindingsFound.isEmpty()) {
            throw new InjectorException('Binding for "' + developerName + '" not found');
        }

        return bindingsFound[0].getInstance(params);
    }

    private List<di_Binding> getBindingsByName(String developerName) {
        return this.Bindings.byName(developerName.toLowerCase().trim()).get();
    }

    public Object getInstance(Type developerNameByType, Schema.SObjectType bindingSObjectType) {
        return getInstance(developerNameByType, bindingSObjectType, null);
    }

    public Object getInstance(Type developerNameByType, Schema.SObjectType bindingSObjectType, Object params) {
        return getInstance(developerNameByType == null ? null : developerNameByType.getName().toLowerCase(), bindingSObjectType, params);
    }

    public Object getInstance(String developerName, Schema.SObjectType bindingSObjectType, Object params) {
        validateParameters(developerName, bindingSObjectType);

        List<di_Binding> bindingsFound = getBindingsByNameAndObject(developerName, bindingSObjectType);

        if (bindingsFound == null || bindingsFound.isEmpty() || bindingsFound[0] == null) {
            throw new InjectorException('Binding for "' + developerName + '" and SObjectType "' + bindingSObjectType + '" not found');
        }

        return bindingsFound[0].getInstance(params);
    }

    private void validateParameters(String developerName, Schema.SObjectType bindingSObjectType) {
        if (String.isBlank(developerName)) {
            throw new InjectorException('Request for Binding cannot take "developerName" parameter of null');
        }

        if (bindingSObjectType == null) {
            throw new InjectorException('Request for Binding cannot take "bindingSObjectType" parameter of null');
        }
    }

    private List<di_Binding> getBindingsByNameAndObject(String developerName, Schema.SObjectType bindingSObjectType) {
        return this.Bindings.bySObject(bindingSObjectType)
            .byName(developerName.toLowerCase().trim())
            .get();
    }

    @testVisible
    private class CustomMetadataModule extends di_Module {

        private string bindingObjectApiName = null;

        @testVisible
        private List<di_BindingConfigWrapper> getDIBinding(){
            List<di_BindingConfigWrapper> recordList = new List<di_BindingConfigWrapper>();

            if(di_Injector.mock_BindingConfigurationWrappersOuter != null) {
                recordList = di_Injector.mock_BindingConfigurationWrappersOuter;
            } else {
                List<di_Binding__mdt> bindingMDTRec = [SELECT QualifiedAPIName
                                                            , DeveloperName
                                                            , BindingName__c
                                                            , NamespacePrefix
                                                            , Type__c
                                                            , To__c
                                                            , BindingObject__c
                                                            , BindingObject__r.QualifiedApiName
                                                            , BindingObjectAlternate__c
                                                            , BindingSequence__c
                                                         FROM di_Binding__mdt];
                for(di_Binding__mdt records :bindingMDTRec) {
                    recordList.add(new di_BindingConfigWrapper(records));
                }
            }
            return recordList;
        }

        public override void configure() {
            for(di_BindingConfigWrapper bindingConfig : getDIBinding()) {
                configureBinding(bindingConfig);
            }
        }

        private void configureBinding(di_BindingConfigWrapper bindingConfig) {
            bind(bindingConfig.DeveloperName);
            type(bindingConfig.Type);

            if (hasBindingObject(bindingConfig)) {
                configureBindingObject(bindingConfig);
            }

            if (hasBindingSequence(bindingConfig)) {
                sequence(Integer.valueOf(bindingConfig.BindingSequence));
            }

            data(bindingConfig);
            to(bindingConfig.To);
        }

        private Boolean hasBindingObject(di_BindingConfigWrapper bindingConfig) {
            return String.isNotBlank(bindingConfig.BindingObject) ||
                   String.isNotBlank(bindingConfig.BindingObjectAlternate);
        }

        private void configureBindingObject(di_BindingConfigWrapper bindingConfig) {
            bindingObjectApiName = getBindingObjectApiName(bindingConfig);
            Schema.DescribeSobjectResult[] results = Schema.describeSObjects(new String[] { bindingObjectApiName });

            if (results.size() != 1) {
                throw new InjectorException('Failed to find SObject ' + bindingObjectApiName + ' referenced by binding ' + bindingConfig.DeveloperName);
            }

            bind(results[0].getSObjectType());
        }

        private String getBindingObjectApiName(di_BindingConfigWrapper bindingConfig) {
            return String.isNotBlank(bindingConfig.BindingObject)
                ? bindingConfig.bindingObjectQualifiedApiName.toLowerCase().trim()
                : bindingConfig.BindingObjectAlternate.toLowerCase().trim();
        }

        private Boolean hasBindingSequence(di_BindingConfigWrapper bindingConfig) {
            return bindingConfig.BindingSequence != null;
        }
    }

    public class InjectorException extends Exception {}
}
```

File `classes\di_Module.cls`:
```apex
public virtual class di_Module {

    private List<di_Binding> bindings = new List<di_Binding>();
    private di_Binding.BindingType bindingType;
    private String developerName;
    private SObjectType bindingObject;
    private Integer bindingSequence;
    private Object to;
    private Object bindingData;

    public di_Module() {
        init();
    }

    public virtual void configure() { }

    public di_Module type(String value) {
        List<di_Binding.BindingType> bindEnumValues = di_Binding.BindingType.values();

        for(di_Binding.BindingType bindEnumValue : bindEnumValues) {
            if(bindEnumValue.name().equals(value)) {
                bindingType = bindEnumValue;
                return this;
            }
        }

        throw new ModuleException('Binding type ' + value + ' is not valid.');
    }

    public di_Module type(di_Binding.BindingType value) {
        bindingType = value;
        return this;
    }

    public di_Module apex() {
        bindingType = di_Binding.BindingType.Apex;
        return this;
    }

    public di_Module lightningComponent() {
        bindingType = di_Binding.BindingType.LightningComponent;
        return this;
    }

    public di_Module visualforceComponent() {
        bindingType = di_Binding.BindingType.VisualforceComponent;
        return this;
    }

    public di_Module flow() {
        bindingType = di_Binding.BindingType.Flow;
        return this;
    }

    public di_Module module() {
        bindingType = di_Binding.BindingType.Module;
        return this;
    }

    public di_Module bind(Type bindingType) {
        developerName = bindingType.getName();
        return this;
    }

    public di_Module bind(SObjectType sObjectType) {
        bindingObject = sObjectType;
        return this;
    }

    public di_Module bind(String bindingName) {
        developerName = bindingName;
        return this;
    }

    public di_Module sequence(Integer sequence) {
        bindingSequence = sequence;
        return this;
    }

    public di_Module data(Object data) {
        bindingData = data;
        return this;
    }

    public di_Module to(String bindingTo) {
        return toObject(bindingTo);
    }

    public di_Module to(Type bindingTo) {
        return toObject(bindingTo.getName());
    }

    public di_Module toObject(Object to) {
        this.to = to;

        if(to instanceof di_Flow) {
            return flow().addBinding();
        }

        return addBinding();
    }

    public List<di_Binding> getBindings() {
        return this.bindings;
    }

    private di_Module addBinding() {
        di_Binding newBinding = createNewBinding();

        bindings.add(newBinding);
        di_PlatformCache.getInstance().addBindingToPlatformCache(newBinding);

        init();
        return this;
    }

    private di_Binding createNewBinding() {
        return di_Binding.newInstance(
            bindingType,
            developerName,
            bindingObject,
            bindingSequence,
            to,
            bindingData
        );
    }

    private void init() {
        bindingType = di_Binding.BindingType.Apex;
        developerName = null;
        bindingObject = null;
        bindingSequence = null;
        to = null;
    }

    public class ModuleException extends Exception {}
}
```

File `classes\di_PlatformCache.cls`:
```apex
public with sharing class di_PlatformCache
{
    public static final Integer NUM_OF_SECS_IN24HR =  86400;

    @TestVisible
    private static final String BINDING_KEY = 'bindingKeyIndex';
    @TestVisible
    private static di_PlatformCache instance;
    @TestVisible
    private Map<String, Map<Schema.SObjectType, Set<String> > > cacheKeyIndexMap = new Map<String, Map<Schema.SObjectType, Set<String> > >();
    @TestVisible
    private static Map<String, String> generatedKeyNames = new Map<String, String>();

    @TestVisible
    private static Boolean DEBUGGING = false;

    private di_PlatformCache() {}

    public static di_PlatformCache getInstance() {
        if (instance == null) {
            instance = new di_PlatformCache();
        }

        return instance;
    }

    public static Boolean isStoringBindingInPlatformCache() {
        return getConfig().UsePlatformCacheToStoreBindings__c == null ?
            false :
            (getConfig().UsePlatformCacheToStoreBindings__c && getPartition() != null);
    }

    public Map<String, Map<Schema.SObjectType, Set<String>>> getCacheKeyIndexMap() {
        if (cacheKeyIndexMap.isEmpty()) {
            loadCacheKeyIndexMapFromPartition();
        }

        return cacheKeyIndexMap;
    }

    private void loadCacheKeyIndexMapFromPartition() {
        try {
            Cache.OrgPartition orgPartition = getPartition();
            if (orgPartition != null) {
                cacheKeyIndexMap = (Map<String, Map<Schema.SObjectType, Set<String> > >) orgPartition.get(getKeyIndexName());
            }
        } catch (Cache.Org.OrgCacheException ex) {
            cacheKeyIndexMap = null;
        }

        if (cacheKeyIndexMap == null) {
            cacheKeyIndexMap = new Map<String, Map<Schema.SObjectType, Set<String> > >();
        }
    }

    public Boolean addBindingToPlatformCache(di_Binding binding) {
        if (!isStoringBindingInPlatformCache()) {
            return false;
        }

        Cache.OrgPartition orgPartition = getPartition();
        if (orgPartition == null) {
            return false;
        }

        String theKeyName = getKeyName(binding);
        List<di_Binding> workingBindings = getExistingBindingsForKey(orgPartition, theKeyName);

        workingBindings.add(binding);
        log('Adding binding for hash => ' + theKeyName + ' && developerName => ' + binding.developerName + ' && object => ' + binding.bindingObject);

        try {
            orgPartition.put(theKeyName, workingBindings, getPartitionTTL(), Cache.Visibility.ALL, false);
        } catch (cache.Org.OrgCacheException oce) {
            log(oce);
        }

        addBindingToKeyIndex(binding);
        return true;
    }

    private List<di_Binding> getExistingBindingsForKey(Cache.OrgPartition orgPartition, String theKeyName) {
        List<di_Binding> workingBindings = new List<di_Binding>();

        if (orgPartition.contains(theKeyName)) {
            workingBindings.addAll((List<di_Binding>) orgPartition.get(theKeyName));
        }

        return workingBindings;
    }

    public list<di_Binding> retrieveBindings(String developerName, Schema.SObjectType bindingSObjectType) {
        list<di_Binding> bindings = new list<di_Binding>();

        if (!shouldRetrieveFromCache(developerName, bindingSObjectType)) {
            return bindings;
        }

        log('Retrieving from Cache Key => ' + developerName + ' && Cache Key Index => ' + bindingSObjectType);

        Cache.OrgPartition orgPartition = getPartition();
        Map<Schema.SObjectType, Set<String> > keyIndexBySObjectTypeMap = getCacheKeyIndexMap().get(developerName.toLowerCase().trim());

        if (keyIndexBySObjectTypeMap == null || orgPartition == null) {
            return bindings;
        }

        Set<String> cacheKeys = keyIndexBySObjectTypeMap.get(bindingSObjectType);
        if (cacheKeys == null) {
            return bindings;
        }

        return getBindingsFromCacheKeys(orgPartition, cacheKeys);
    }

    private Boolean shouldRetrieveFromCache(String developerName, Schema.SObjectType bindingSObjectType) {
        return isStoringBindingInPlatformCache() &&
               string.isNotBlank(developerName) &&
               bindingSObjectType != null;
    }

    private list<di_Binding> getBindingsFromCacheKeys(Cache.OrgPartition orgPartition, Set<String> cacheKeys) {
        list<di_Binding> bindings = new list<di_Binding>();
        Object cachedObject = null;

        for (String cacheKey : cacheKeys) {
            cachedObject = orgPartition.get(cacheKey);
            if (cachedObject != null) {
                bindings.addAll((List<di_Binding>) cachedObject);
            }
        }

        return bindings;
    }

    public static void clearCachedBindings() {
        Set<String> keys = getPartitionKeys();

        if (keys == null) {
            return;
        }

        String partitionKey = getPartitionName();
        Cache.OrgPartition partition = getPartition();

        for (String key : partition.getKeys()) {
            try {
                partition.remove(key);
            } catch (Exception ex) {
                log('XX]> Unable to remove Platform Cache partition [' + partitionKey + '] key [' + key + ']');
            }
        }
    }

    public static Set<String> getPartitionKeys() {
        Set<String> keys = null;
        Cache.OrgPartition partition = getPartition();

        if (partition != null) {
            keys = partition.getKeys();
        }

        return keys;
    }

    @TestVisible
    private static di_Configurations__c getConfig() {
        di_Configurations__c config = di_Configurations__c.getInstance();

        if (config == null) {
            config = createNewConfig();
        }

        return config;
    }

    private static di_Configurations__c createNewConfig() {
        di_Configurations__c config = new di_Configurations__c();
        config.SetupOwnerId = ConnectApi.Organization.getSettings().orgId;

        if (di_Configurations__c.SObjectType.getDescribe().isCreateable()) {
            insert config;
        }

        return config;
    }

    @TestVisible
    private static String getPartitionName() {
        return getConfig().OrgCachePartitionName__c;
    }

    @TestVisible
    private Integer getPartitionTTL() {
        return NUM_OF_SECS_IN24HR;
    }

    @TestVisible
    private static Cache.OrgPartition getPartition() {
        Cache.OrgPartition result = null;

        try {
            result = Cache.Org.getPartition(getPartitionName());
        } catch (Exception excp) {
            log('ERROR: Is there Cache? Is the Cache Partition enabled : Exception:' + excp);
        }

        return result;
    }

    @TestVisible
    private boolean pushCacheKeyIndexMapToCache() {
        Cache.OrgPartition orgPartition = getPartition();

        if (orgPartition != null) {
            orgPartition.put(getKeyIndexName(), this.cacheKeyIndexMap, getPartitionTTL(), Cache.Visibility.ALL, false);
        }

        return orgPartition != null;
    }

    @TestVisible
    private void addBindingToKeyIndex(di_Binding binding) {
        if (binding == null) {
            return;
        }

        String workingDeveloperName = binding.developerName.toLowerCase().trim();

        initializeKeyIndexForDeveloperName(workingDeveloperName);
        initializeKeyIndexForBindingObject(workingDeveloperName, binding);

        getCacheKeyIndexMap().get(workingDeveloperName).get(binding.bindingObject).add(getKeyName(binding));
        pushCacheKeyIndexMapToCache();
    }

    private void initializeKeyIndexForDeveloperName(String workingDeveloperName) {
        if (!getCacheKeyIndexMap().containsKey(workingDeveloperName)) {
            getCacheKeyIndexMap().put(workingDeveloperName, new Map<Schema.SObjectType, Set<String>>());
        }
    }

    private void initializeKeyIndexForBindingObject(String workingDeveloperName, di_Binding binding) {
        if (!getCacheKeyIndexMap().get(workingDeveloperName).containsKey(binding.bindingObject)) {
            getCacheKeyIndexMap().get(workingDeveloperName).put(binding.bindingObject, new Set<String>());
        }
    }

    @TestVisible
    private String constructKeyName(Schema.SObjectType bindingSObjectType, String developerName) {
        if (String.isBlank(developerName)) {
            return null;
        }

        String key = buildKeyString(bindingSObjectType, developerName);

        if (generatedKeyNames.containsKey(key)) {
            return generatedKeyNames.get(key);
        }

        String hash = generateHashForKey(key, developerName, bindingSObjectType);
        generatedKeyNames.put(key, hash);
        return hash;
    }

    private String buildKeyString(Schema.SObjectType bindingSObjectType, String developerName) {
        String objectName = (bindingSObjectType != null) ?
            bindingSObjectType.getDescribe().getName().toLowerCase().replaceAll('__','') :
            '';

        return objectName + (String.isBlank(developerName) ? '' : developerName.toLowerCase().trim());
    }

    private String generateHashForKey(String key, String developerName, Schema.SObjectType bindingSObjectType) {
        String hash = String.valueOf(Math.abs((key).hashcode()));
        log('Creating Hash For => ' + developerName + ' && ' + bindingSObjectType + ' := ' + hash);
        return hash;
    }

    @TestVisible
    private String getKeyName(String developerName, Schema.SObjectType bindingSObjectType) {
        return constructKeyName(bindingSObjectType, developerName);
    }

    @TestVisible
    private String getKeyName(di_Binding binding) {
        return constructKeyName(binding.bindingObject, binding.developerName);
    }

    @TestVisible
    private String getKeyIndexName() {
        return di_PlatformCache.BINDING_KEY;
    }

    @TestVisible
    private static Boolean log(Exception excp) {
        Boolean before = DEBUGGING, result;

        DEBUGGING = true;
        result = log('Exception: ' + excp.getMessage());
        DEBUGGING = before;
        return result;
    }

    @TestVisible
    private static Boolean log(String message) {
        Boolean doLog = DEBUGGING && string.isNotBlank(message);

        if (doLog) {
            system.debug('+++ di_PlatformCache.message: ' + message);
        }

        return doLog;
    }
}
```

The refactoring focuses on:
1. Breaking down complex methods into smaller, more focused methods
2. Extracting helper methods to reduce cognitive complexity
3. Simplifying conditional logic
4. Improving code organization and readability
5. Maintaining all the original functionality while making the code more maintainable

The changes preserve all the original behavior while making the code more readable and easier to maintain.