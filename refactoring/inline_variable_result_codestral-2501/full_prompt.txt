Inline_Variable
Task Description
You are a strict code refactoring engine. You follow all rules exactly as written. Your task is to perform an Inline Variable refactoring in an Apex project. Certain temporary variables should be inlined by replacing the variable with its defining value or expression wherever it is used.

Please note:
1. The code must still function perfectly after the refactoring.
2. All imports, references, and method calls must be updated accordingly.
3. The style, formatting, and structure of the code must be preserved.
4. Do not introduce any new functionality, logic changes, or unrelated formatting changes.
5. For every modified file, return the complete updated file content to ensure that no changes are overlooked.
6. The semantics and behavior of the code must not change.
7. Only include files that required changes.
8. Respond with the code blocks only. Your entire response must be machine readable. Do not include any conversational filler.
9. If you are unsure, do not guess. Only modify code when the change is certain.
10. Every response must include meaningful modifications, improvements, or transformations. Returning the same code, even partially or with superficial edits, is strictly prohibited.
11. Your final output must pass the existing test suite. If your changes would cause any test to fail, revise your refactor until all tests pass.

Examples of inline variable tasks:

Example 1:
Original Code:
File `CalculateTotal.cls`:
```apex
public class CalculateTotal {
    public static Decimal calculateTotal(Decimal price, Integer quantity) {
        Decimal subtotal = price * quantity;
        return subtotal;
    }
}
```

Task:
1. Inline the temporary variable subtotal in the method calculateTotal in the file CalculateTotal.cls.
2. Update every relevant occurrence across the entire project.
3. Output format (for EACH modified file):

File `CalculateTotal.cls`:
```apex
public class CalculateTotal {
    public static Decimal calculateTotal(Decimal price, Integer quantity) {
        return price * quantity;
    }
}
```

Example 2:
Original Code:
File `UserUtil.cls`:
```apex
public class UserUtil {
    public static String getUserName(Map<String, Object> user) {
        String name = (String)user.get('name');
        return name;
    }
}
```

Task:
1. Inline the temporary variable name in the method getUserName in the file UserUtil.cls.
2. Update every relevant occurrence across the entire project.
3. Output format (for EACH modified file):

File `UserUtil.cls`:
```apex
public class UserUtil {
    public static String getUserName(Map<String, Object> user) {
        return (String)user.get('name');
    }
}
```

Your Task:
1. Inline the temporary variable `hashValue` in the method `toString`  in the file `di_Binding.cls`.
2. Update every relevant occurrence across the entire project.
3. For EACH modified file, respond exactly in the following format:

File `Filename.cls`:
```apex
[Complete updated file content]
```


Struktur:
main/
  aura/
    di_injector/
    di_injectorAttribute/
    di_injectorAttributeChangeEvent/
    di_injectorFlowProxy/
    di_injectorFlowProxyStatusChanged/
  classes/
    di_Binding.cls
    di_BindingConfigWrapper.cls
    di_BindingParam.cls
    di_Flow.cls
    di_Injector.cls
    di_InjectorComponentController.cls
    di_InjectorComponentFlowProxyController.cls
    di_InjectorController.cls
    di_Module.cls
    di_NamespaceClass.cls
    di_PlatformCache.cls
  components/
  layouts/
  objects/
    di_Binding__mdt/
      fields/
      listViews/
      validationRules/
    di_Configurations__c/
      fields/

Code:


File `classes\di_Binding.cls`:
```apex
public abstract class di_Binding implements Comparable {

    public BindingType BindingType {get; private set;}

    @AuraEnabled
    public String BindingTypeAsString {get { return BindingType.name();} }

    @AuraEnabled
    public String NamespacePrefix {get;private set;}

    @AuraEnabled
    public String DeveloperName {get;private set;}

    @AuraEnabled
    public SObjectType BindingObject {get;private set;}

    @AuraEnabled
    public Integer BindingSequence {get;private set;}

    @AuraEnabled
    public Object To {get;private set;}

    @AuraEnabled
    public Object Data {get;private set;}

    private Boolean IsProvider = false;
    private Object Injected = null;

    public Object getInstance() {
        return getInstance(null, false);
    }

    public Object getInstance(Object params) {
        return getInstance(params, false);
    }

    public Object getInstance(Object params, Boolean newInstance) {
        if(IsProvider) {
            return newInstance(params);
        } else if(newInstance == true) {
            return newInstance(params);
        } else if(Injected == null) {
            Injected = newInstance(params);
        }
        return Injected;
    }

    public abstract Object newInstance(Object params);

    public Integer compareTo(Object compareTo) {
        di_Binding binding = (di_Binding) compareTo;
        return this.toString().compareTo(binding.toString());
    }

    public override String toString() {
        String hashValue =
            (BindingObject != null) ?
            BindingObject.getDescribe().getName() :
            DeveloperName;
        if(BindingSequence != null) {
            hashValue += '#' + String.valueOf(BindingSequence).leftPad(4,'0');
        }
        return hashValue;
    }

    public interface Provider {
        Object newInstance(Object params);
    }

    public class Resolver {

        private String developerName;
        private SObjectType bindingObject;
        private boolean bindingsAreRequired = true;

        private List<di_Module> modules = null;

        private List<di_Binding> bindings = null;

        public Resolver(List<di_Module> modules) {
            this.modules = modules;
        }

        public Resolver set(di_Module module) {
            modules.clear();
            modules.add(module);

            bindings = null;
            return this;
        }

        public Resolver add(di_Module module) {
            modules.add(module);

            bindings = null;
            return this;
        }

        public Resolver byName(String developerName) {
            this.developerName = developerName;
            return this;
        }

        public Resolver bySObject(SObjectType bindingObject) {
            this.bindingObject = bindingObject;
            return this;
        }

        public Resolver emptyBindingsAllowed() {
            bindingsAreRequired = false;
            return this;
        }

        public Resolver replaceBindingWith( Object mockType )
        {

            loadBindings();

            for (Integer currentBindingsIndex = 0; currentBindingsIndex < this.bindings.size(); currentBindingsIndex++)
            {
                if ( isBindingMatchByFilteringCriteria( this.bindings[currentBindingsIndex] ) )
                {
                    this.bindings[currentBindingsIndex] = di_Binding.newInstance(di_Binding.BindingType.Apex, this.developerName, this.bindingObject, null, mockType, null);
                    break;
                }
            }

            this.developerName = null;
            this.bindingObject = null;

            return this;
        }

        private Boolean isBindingMatchByFilteringCriteria( di_Binding bind )
        {

            Boolean isMatch = false;

            if ( String.isNotBlank(this.developerName) && this.bindingObject != null )
            {
                if ( ( this.developerName.equalsIgnoreCase( bind.DeveloperName )
                        || this.developerName.equalsIgnoreCase( di_NamespaceClass.CURRENTNAMESPACE + '.' + bind.DeveloperName )
                        )
                    && this.bindingObject == bind.BindingObject )
                {
                    isMatch = true;
                }
            }
            else {

                if ( String.isNotBlank(this.developerName)
                    && ( this.developerName.equalsIgnoreCase( bind.DeveloperName )
                        || this.developerName.equalsIgnoreCase( di_NamespaceClass.CURRENTNAMESPACE + '.' + bind.DeveloperName )
                        )
                    )
                {
                    isMatch = true;
                }
                else if (this.bindingObject != null && bind.BindingObject == this.bindingObject)
                {
                    isMatch = true;
                }
            }

            return isMatch;
        }

        private void loadBindings()
        {
            if ( this.bindings == null )
            {

                this.bindings = new List<di_Binding>();
                for (di_Module module : modules)
                {
                    module.configure();
                    for(di_Binding bind : module.getBindings()) {
                        if(bind.BindingType == di_Binding.BindingType.Module) {
                            di_Module embeddedModule = (di_Module) bind.getInstance();
                            embeddedModule.configure();
                            this.bindings.addAll(embeddedModule.getBindings());
                        } else {
                            this.bindings.add(bind);
                        }
                    }
                }
            }
        }

        public List<di_Binding> get()
        {
            list<di_Binding> matchedBindings = di_PlatformCache.getInstance().retrieveBindings(this.developerName, this.bindingObject);

            if ( ( di_PlatformCache.isStoringBindingInPlatformCache() && bindingsAreRequired && matchedBindings.isEmpty() )
                || ! di_PlatformCache.isStoringBindingInPlatformCache()
                )
            {

                loadBindings();

                for (di_Binding bind : bindings)
                {
                    if ( isBindingMatchByFilteringCriteria(bind) )
                    {
                        matchedBindings.add(bind);
                    }
                }
            }

            this.developerName = null;
            this.bindingObject = null;
            matchedBindings.sort();

            this.bindingsAreRequired = true;

            return matchedBindings;
        }
    }

    public class BindingException extends Exception {}

    public enum BindingType { Apex, VisualforceComponent, LightningComponent, Flow, Module }

    public static di_Binding newInstance(
            BindingType bindType,
            String developerName,
            SObjectType bindingObject,
            Integer bindingSequence,
            Object to,
            Object bindingData)
    {

        Type implType = BINDING_IMPLS_BY_TYPE.get(bindType);

        if ( implType != null ) {
            di_Binding binding = (di_Binding) implType.newInstance();
            binding.BindingType = bindType;
            binding.DeveloperName = developerName;
            binding.BindingObject = bindingObject;
            binding.BindingSequence = bindingSequence;
            binding.To = to;
            binding.Data = bindingData;
            return binding;
        }
        throw new BindingException('Binding type ' + bindType + ' has no implementation.');
    }

    private static final Map<BindingType, Type> BINDING_IMPLS_BY_TYPE =
        new Map<BindingType, Type> {
            BindingType.Apex => ApexBinding.class,
            BindingType.LightningComponent => LightningComponentBinding.class,
            BindingType.VisualforceComponent => VisualForceComponentBinding.class,
            BindingType.Flow => FlowBinding.class,
            BindingType.Module => ApexBinding.class
        };

    private class ApexBinding extends di_Binding
    {
        public override Object newInstance(Object params)
        {

            if ( To instanceof String )
            {

                String className = (String) To;
                Type toType = NameSpacePrefix == null ? Type.forName(className) : Type.forName(NamespacePrefix, className);
                if ( toType == null )
                {
                    throw new BindingException('Apex binding ' + DeveloperName + ' implementation ' + To + ' does not exist');
                }
                Object toObject = toType.newInstance();

                IsProvider = toObject instanceof Provider;
                if ( IsProvider )
                {
                    return ((Provider) toObject).newInstance(params);
                }
                else if ( params != null )
                {

                    throw new BindingException('Apex binding ' + DeveloperName + ' implementation ' + className + ' does not implement the Provider interface.');
                }
                return toObject;
            }

            return To;
        }
    }

    private class VisualForceComponentBinding extends di_Binding
    {
        public  override Object newInstance(Object params)
        {

            if ( To instanceof String )
            {

                String className = (String) To;
                Type toType = NamespacePrefix == null ? Type.forName(className) : Type.forName(NamespacePrefix, className);
                if ( toType == null )
                {
                    throw new BindingException('Visualforce Component binding ' + DeveloperName + ' implementation ' + className + ' does not exist.');
                }

                Object toObject = toType.newInstance();
                IsProvider = toObject instanceof Provider;
                if ( IsProvider )
                {
                    return ((Provider) toObject).newInstance(params);
                }
                throw new BindingException('Visualforce Component binding ' + DeveloperName + ' must point to a class implementing the Provider interface.');
            }

            return To;
        }
    }

    private class LightningComponentBinding extends di_Binding
    {
        public override Object newInstance(Object params)
        {

            return To;
        }
    }

    private class FlowBinding extends di_Binding
    {
        public  override Object newInstance(Object params)
        {

            if ( To instanceof String )
            {
                String flowName = (String) To;
                if ( params instanceof Map<String, Object> )
                {
                    return new di_Flow(Flow.Interview.createInterview(flowName, (Map<String, Object>) params));
                }
                return new di_Flow(Flow.Interview.createInterview(flowName, new Map<String, Object>()));
            }

            return To;
        }
    }
}```


File `classes\di_BindingConfigWrapper.cls`:
```apex
global with sharing class di_BindingConfigWrapper {
    
    global di_BindingConfigWrapper(   String qualifiedAPIName
                                    , String developerName
                                    , String namespacePrefix
                                    , String type
                                    , String to
                                    , String bindingObject
                                    , String bindingObjectQualifiedApiName
                                    , String bindingObjectAlternate
                                    , Decimal bindingSequence){
        this.QualifiedAPIName = qualifiedAPIName;
        this.DeveloperName = developerName;
        this.NamespacePrefix = namespacePrefix;
        this.Type = type;
        this.To = to;
        this.BindingObject = bindingObject;
        this.BindingObjectQualifiedApiName = bindingObjectQualifiedApiName;
        this.BindingObjectAlternate = bindingObjectAlternate;
        this.BindingSequence = bindingSequence;
    }
   
    global di_BindingConfigWrapper(di_Binding__mdt bindingConfig){
        this.QualifiedAPIName = bindingConfig.QualifiedApiName;
        this.DeveloperName = String.isBlank(bindingConfig.BindingName__c) ? bindingConfig.DeveloperName : bindingConfig.BindingName__c;
        this.NamespacePrefix = bindingConfig.NamespacePrefix;
        this.Type = bindingConfig.Type__c;
        this.To = bindingConfig.To__c;
        this.BindingObject = bindingConfig.BindingObject__c;
        this.BindingObjectQualifiedApiName = bindingConfig.BindingObject__r.QualifiedApiName;
        this.BindingObjectAlternate = bindingConfig.BindingObjectAlternate__c;
        this.BindingSequence = bindingConfig.BindingSequence__c;
    }
    global String QualifiedAPIName{get;set;}
    global String DeveloperName{get;set;}
    global String NamespacePrefix{get;set;}
    global String Type{get;set;}
    global String To{get;set;}
    global String BindingObject{get;set;}
    global String BindingObjectQualifiedApiName{get;set;}
    global String BindingObjectAlternate{get;set;}
    global Decimal BindingSequence{get;set;}
}
```


File `classes\di_BindingParam.cls`:
```apex


public with sharing class di_BindingParam {

    public static Map<String, Object> parameters { get; set; }

    

    @InvocableMethod(
        label = 'Get Value'
    )
    public static List<Response> invoke( List<Request> requests ) {

        List<Response> responses = new List<Response>();

        for ( Request req : requests ) {

            Response res = new Response();

            if ( parameters != null ) {

                Object value = parameters.get( req.paramName );

                if ( value != null ) {

                    if ( value instanceof Decimal ) { 

                        Decimal decimalValue = (Decimal) value;
                        res.longValue = toLongValue( decimalValue );
                        res.decimalValue = decimalValue;
                        res.stringValue = toStringValue( decimalValue );
                        res.booleanValue = toBooleanValue( decimalValue );
                        res.dateValue = toDateValue( decimalValue );
                        res.dateTimeValue = toDateTimeValue( decimalValue );

                    } else if ( value instanceof Decimal[] ) {

                        Decimal[] decimalValues = (Decimal[]) value;
                        res.decimalValues = decimalValues;
                        for ( Decimal decimalValue : decimalValues ) {
                            res.longValues.add( toLongValue( decimalValue ) );
                            res.stringValues.add( toStringValue( decimalValue ) );
                            res.booleanValues.add( toBooleanValue( decimalValue ) );
                            res.dateValues.add( toDateValue( decimalValue ) );
                            res.dateTimeValues.add( toDateTimeValue( decimalValue ) );
                        }

                    } else if ( value instanceof String ) {

                        String stringValue = (String) value;
                        res.longValue = toLongValue( stringValue );
                        res.decimalValue = toDecimalValue( stringValue );
                        res.stringValue = stringValue;
                        res.booleanValue = toBooleanValue( stringValue );
                        res.dateValue = toDateValue( stringValue );
                        res.dateTimeValue = toDateTimeValue( stringValue );

                    } else if ( value instanceof String[] ) {

                        String[] stringValues = (String[]) value;
                        res.stringValues = stringValues;
                        for ( String stringValue : stringValues ) {
                            res.longValues.add( toLongValue( stringValue ) );
                            res.decimalValues.add( toDecimalValue( stringValue ) );
                            res.booleanValues.add( toBooleanValue( stringValue ) );
                            res.dateValues.add( toDateValue( stringValue ) );
                            res.dateTimeValues.add( toDateTimeValue( stringValue ) );
                        }

                    } else if ( value instanceof Boolean ) {

                        Boolean booleanValue = (Boolean) value;
                        res.longValue = toLongValue( booleanValue );
                        res.decimalValue = toDecimalValue( booleanValue );
                        res.stringValue = toStringValue( booleanValue );
                        res.booleanValue = booleanValue;
                        res.dateValue = toDateValue( booleanValue );
                        res.dateTimeValue = toDateTimeValue( booleanValue );

                    } else if ( value instanceof Boolean[] ) {

                        Boolean[] booleanValues = (Boolean[]) value;
                        res.booleanValues = booleanValues;
                        for ( Boolean booleanValue : booleanValues ) {
                            res.longValues.add( toLongValue( booleanValue ) );
                            res.decimalValues.add( toDecimalValue( booleanValue ) );
                            res.stringValues.add( toStringValue( booleanValue ) );
                            res.dateValues.add( toDateValue( booleanValue ) );
                            res.dateTimeValues.add( toDateTimeValue( booleanValue ) );
                        }

                    } else if ( value instanceof Date ) {

                        Date dateValue = (Date) value;
                        res.longValue = toLongValue( dateValue );
                        res.decimalValue = toDecimalValue( dateValue );
                        res.stringValue = toStringValue( dateValue );
                        res.booleanValue = toBooleanValue( dateValue );
                        res.dateValue = dateValue;
                        res.dateTimeValue = toDateTimeValue( dateValue );

                    } else if ( value instanceof Date[] ) {

                        Date[] dateValues = (Date[]) value;
                        res.dateValues = dateValues;
                        for ( Date dateValue : dateValues ) {
                            res.longValues.add( toLongValue( dateValue ) );
                            res.decimalValues.add( toDecimalValue( dateValue ) );
                            res.stringValues.add( toStringValue( dateValue ) );
                            res.booleanValues.add( toBooleanValue( dateValue ) );
                            res.dateTimeValues.add( toDateTimeValue( dateValue ) );
                        }

                    } else if ( value instanceof DateTime ) {

                        DateTime dateTimeValue = (DateTime) value;
                        res.longValue = toLongValue( dateTimeValue );
                        res.decimalValue = toDecimalValue( dateTimeValue );
                        res.stringValue = toStringValue( dateTimeValue );
                        res.booleanValue = toBooleanValue( dateTimeValue );
                        res.dateValue = toDateValue( dateTimeValue );
                        res.dateTimeValue = dateTimeValue;

                    } else if ( value instanceof DateTime[] ) {

                        DateTime[] dateTimeValues = (DateTime[]) value;
                        res.dateTimeValues = dateTimeValues;
                        for ( DateTime dateTimeValue : dateTimeValues ) {
                            res.longValues.add( toLongValue( dateTimeValue ) );
                            res.decimalValues.add( toDecimalValue( dateTimeValue ) );
                            res.stringValues.add( toStringValue( dateTimeValue ) );
                            res.booleanValues.add( toBooleanValue( dateTimeValue ) );
                            res.dateValues.add( toDateValue( dateTimeValue ) );
                        }

                    }

                    
                    if ( res.longValue     == null && !res.longValues.isEmpty() )     { res.longValue = res.longValues[0]; }
                    if ( res.decimalValue  == null && !res.decimalValues.isEmpty() )  { res.decimalValue = res.decimalValues[0]; }
                    if ( res.stringValue   == null && !res.stringValues.isEmpty() )   { res.stringValue = res.stringValues[0]; }
                    if ( res.booleanValue  == null && !res.booleanValues.isEmpty() )  { res.booleanValue = res.booleanValues[0]; }
                    if ( res.dateValue     == null && !res.dateValues.isEmpty() )     { res.dateValue = res.dateValues[0]; }
                    if ( res.dateTimeValue == null && !res.dateTimeValues.isEmpty() ) { res.dateTimeValue = res.dateTimeValues[0]; }

                    
                    if ( res.longValue     != null && res.longValues.isEmpty() )     { res.longValues.add( res.longValue ); }
                    if ( res.decimalValue  != null && res.decimalValues.isEmpty() )  { res.decimalValues.add( res.decimalValue ); }
                    if ( res.stringValue   != null && res.stringValues.isEmpty() )   { res.stringValues.add( res.stringValue ); }
                    if ( res.booleanValue  != null && res.booleanValues.isEmpty() )  { res.booleanValues.add( res.booleanValue ); }
                    if ( res.dateValue     != null && res.dateValues.isEmpty() )     { res.dateValues.add( res.dateValue ); }
                    if ( res.dateTimeValue != null && res.dateTimeValues.isEmpty() ) { res.dateTimeValues.add( res.dateTimeValue ); }

                } else {

                    System.debug( LoggingLevel.WARN, 'BindingParam.parameters.get("' + req + '") is null' );

                }

            } else {

                System.debug( LoggingLevel.WARN, 'BindingParam.parameters is null' );

            }

            System.debug( 'paramName=' + req );
            System.debug( res );

            responses.add( res );

        }

        return responses;
    }

    
    

    private static Long toLongValue( Decimal value ) {
        return ( value == null ? null : value.longValue() );
    }

    private static Long toLongValue( String value ) {
        return ( ( value == null || !value.isNumeric() ) ? null : Long.valueOf( value ) );
    }

    private static Long toLongValue( Boolean value ) {
        return ( value == null ? null : value ? 1 : 0 );
    }

    private static Long toLongValue( Date value ) {
        return ( value == null ? null : toLongValue(
            DateTime.newInstance( value.year(), value.month(), value.day(), 0, 0, 0 )
        ));
    }

    private static Long toLongValue( DateTime value ) {
        return ( value == null ? null : value.getTime() );
    }

    
    

    private static Decimal toDecimalValue( String value ) {
        return ( ( value == null || !value.isNumeric() ) ? null : Decimal.valueOf( value ) );
    }

    private static Decimal toDecimalValue( Boolean value ) {
        return ( value == null ? null : value ? 1 : 0 );
    }

    private static Decimal toDecimalValue( Date value ) {
        return ( value == null ? null : toDecimalValue(
            DateTime.newInstance( value.year(), value.month(), value.day(), 0, 0, 0 )
        ));
    }

    private static Decimal toDecimalValue( DateTime value ) {
        return ( value == null ? null : value.getTime() );
    }

    
    

    
    
    
    
    private static String toStringValue( Date value ) {
        return ( value == null ? null : String.valueOf( value ) );
    }

    private static String toStringValue( DateTime value ) {
        return ( value == null ? null : String.valueOf( value ) );
    }

    private static String toStringValue( Object value ) {
        return ( value == null ? null : String.valueOf( value ) );
    }

    
    

    private static Boolean toBooleanValue( Decimal value ) {
        return ( value == null ? false : ( value > 0 ) );
    }

    private static Boolean toBooleanValue( String value ) {
        return ( value == null ? false : Boolean.valueOf( value ) );
    }

    private static Boolean toBooleanValue( Date value ) {
        return ( value == null ? false : true );
    }

    private static Boolean toBooleanValue( DateTime value ) {
        return ( value == null ? false : true );
    }

    
    

    private static Date toDateValue( Decimal value ) {
        return ( value == null ? null : DateTime.newInstance( value.longValue() ).date() );
    }

    private static Date toDateValue( String value ) {
        try {
            return ( value == null ? null : Date.valueOf( value ) ); 
        } catch ( Exception e ) {
            return null;
        }
    }

    private static Date toDateValue( Boolean value ) {
        return null;
    }

    private static Date toDateValue( DateTime value ) {
        return ( value == null ? null : value.date() );
    }

    
    

    private static DateTime toDateTimeValue( Decimal value ) {
        return ( value == null ? null : DateTime.newInstance( value.longValue() ) );
    }

    private static DateTime toDateTimeValue( String value ) {
        try {
            return ( value == null ? null : DateTime.valueOf( value ) ); 
        } catch ( Exception e ) {
            return toDateValue( value ); 
        }
    }

    private static DateTime toDateTimeValue( Boolean value ) {
        return null;
    }

    private static DateTime toDateTimeValue( Date value ) {
        return ( value == null ? null : DateTime.newInstance( value.year(), value.month(), value.day(), 0, 0, 0 ) );
    }

    

    public class Request {

        @InvocableVariable(
            label = 'Parameter Name'
            required = true
        )
        public String paramName;

    }

    public class Response {

        @InvocableVariable(
            label = 'Number'
            description = 'Whole number (no decimals)'
        )
        public Long longValue;

        @InvocableVariable(
            label = 'Decimal'
            description = 'Number that may include decimal places'
        )
        public Decimal decimalValue;

        @InvocableVariable(
            label = 'Text'
            description = 'Text value'
        )
        public String stringValue;

        @InvocableVariable(
            label = 'Boolean'
            description = 'true/false'
        )
        public Boolean booleanValue;

        @InvocableVariable(
            label = 'Date'
        )
        public Date dateValue;

        @InvocableVariable(
            label = 'Date/Time'
        )
        public DateTime dateTimeValue;

        @InvocableVariable(
            label = 'Number Collection'
            description = 'Collection of whole numbers'
        )
        public Long[] longValues = new Long[] {};

        @InvocableVariable(
            label = 'Decimal Collection'
            description = 'Collection of numbers that may include decimal places'
        )
        public Decimal[] decimalValues = new Decimal[] {};

        @InvocableVariable(
            label = 'Text Collection'
            description = 'Collection of text values'
        )
        public String[] stringValues = new String[] {};

        @InvocableVariable(
            label = 'Boolean Collection'
            description = 'Collection of true/false values'
        )
        public Boolean[] booleanValues = new Boolean[] {};

        @InvocableVariable(
            label = 'Date Collection'
            description = 'Collection of date values'
        )
        public Date[] dateValues = new Date[] {};

        @InvocableVariable(
            label = 'Date/Time Collection'
            description = 'Collection of date/time values'
        )
        public DateTime[] dateTimeValues = new DateTime[] {};

    }

}```


File `classes\di_Flow.cls`:
```apex



public class di_Flow {

    private Flow.Interview flow = null;
    @testVisible
    private Set<String> outputVarsNames;
    @testVisible
    private Set<String> outputVarsNamesRequired;

    public di_Flow(Flow.Interview flow) {
        this.flow = flow;
        init();
    }

    
    public di_Flow output(String variableName) {
        outputVarsNames.add(variableName);
        return this;
    }

    
    public di_Flow required(String variableName) {
        output(variableName);
        outputVarsNamesRequired.add(variableName);
        return this;
    }

    
    public Map<String, Object> run() {
        try {
            flow.start();
            Map<String, Object> outputVars = new Map<String, Object>();
            for(String outputVar : outputVarsNames) {
                Object outputVarValue = flow.getVariableValue(outputVar);
                if(outputVarValue != null) {
                    outputVars.put(outputVar, outputVarValue);
                } else if(outputVarsNamesRequired.contains(outputVar)) {
                    throw new FlowException('Output variable ' + outputVar + ' expected but not returned from Flow');
                }
            }
            return outputVars;
        }
        finally {
            init();
        }
    }

    
    public Object returning(String outputVariableName) {
        return required(outputVariableName).run().get(outputVariableName);
    }

    
    private void init() {
        outputVarsNames = new Set<String>();
        outputVarsNamesRequired = new Set<String>();
    }

    public class FlowException extends Exception {}
}```


File `classes\di_Injector.cls`:
```apex


public class di_Injector {
    @testVisible
    private static List<di_BindingConfigWrapper> mock_BindingConfigurationWrappersOuter = null;
    
    public static final di_Injector Org =
        new di_Injector(
            new List<di_Module> {
        new CustomMetadataModule()
    });

    
    @TestVisible
    public di_Binding.Resolver Bindings {get; private set;}

    
    public di_Injector(di_Module module) {
        this(new List<di_Module> { module });
    }

    
    public di_Injector(List<di_Module> modules) {
        Bindings = new di_Binding.Resolver(modules);
    }

    
    public Object getInstance(Type developerNameByType) {
        return getInstance(developerNameByType?.getName()?.toLowerCase(), null);
    }

    
    public Object getInstance(Type developerNameByType, Object params) {
        return getInstance(developerNameByType?.getName()?.toLowerCase(), params);
    }

    
    public Object getInstance(String developerName) {
        return getInstance(developerName, null);
    }

    
    public Object getInstance(String developerName, Object params) {
        if ( String.isBlank(developerName) ) {
            throw new InjectorException('Request for Binding cannot take "developerName" parameter of null');
        }
        List<di_Binding> bindingsFound = this.Bindings.byName( developerName.toLowerCase().trim() ).get();
        if ( bindingsFound == null || bindingsFound.isEmpty() ) {
            throw new InjectorException('Binding for "' + developerName + '" not found');
        }
        return bindingsFound[0].getInstance(params);
    }

    
    public Object getInstance(Type developerNameByType, Schema.SObjectType bindingSObjectType) {
        return getInstance(developerNameByType, bindingSObjectType, null);
    }

    
    public Object getInstance(Type developerNameByType, Schema.SObjectType bindingSObjectType, Object params) {
        return getInstance(developerNameByType == null ? null : developerNameByType.getName().toLowerCase(), bindingSObjectType, params);
    }

    
    public Object getInstance(String developerName, Schema.SObjectType bindingSObjectType, Object params) {
        if ( String.isBlank(developerName) ) {
            throw new InjectorException('Request for Binding cannot take "developerName" parameter of null');
        }

        if ( bindingSObjectType == null ) {
            throw new InjectorException('Request for Binding cannot take "bindingSObjectType" parameter of null');
        }

        List<di_Binding> bindingsFound = this.Bindings.bySObject( bindingSObjectType )
                                         .byName( developerName.toLowerCase().trim() )
                                         .get();

        if ( bindingsFound == null || bindingsFound.isEmpty() || bindingsFound[0] == null) {
            throw new InjectorException('Binding for "' + developerName + '" and SObjectType "' + bindingSObjectType + '" not found');
        }
        return bindingsFound[0].getInstance(params);

    }

    
    @testVisible
    private class CustomMetadataModule extends di_Module {

        private string bindingObjectApiName = null;
        
        
        @testVisible
        private List<di_BindingConfigWrapper> getDIBinding(){
            List<di_BindingConfigWrapper> recordList = new List<di_BindingConfigWrapper>();

            
            if(di_Injector.mock_BindingConfigurationWrappersOuter != null) {
                recordList = di_Injector.mock_BindingConfigurationWrappersOuter;
            } else {
                List<di_Binding__mdt> bindingMDTRec = [SELECT QualifiedAPIName
                                                            , DeveloperName
                                                            , BindingName__c
                                                            , NamespacePrefix
                                                            , Type__c
                                                            , To__c
                                                            , BindingObject__c
                                                            , BindingObject__r.QualifiedApiName
                                                            , BindingObjectAlternate__c
                                                            , BindingSequence__c
                                                         FROM di_Binding__mdt];
                for(di_Binding__mdt records :bindingMDTRec) {
                    recordList.add(new di_BindingConfigWrapper(records));
                }
            }
            return recordList;
        }
        public override void configure() {
            
            for(di_BindingConfigWrapper bindingConfig :getDIBinding()) {
                bind(bindingConfig.DeveloperName);
                type(bindingConfig.Type);
                if(String.isNotBlank(bindingConfig.BindingObject)
                    || String.isNotBlank(bindingConfig.BindingObjectAlternate)) {
                    bindingObjectApiName =  String.isNotBlank(bindingConfig.BindingObject)
                                            ? bindingConfig.bindingObjectQualifiedApiName.toLowerCase().trim()
                                            : bindingConfig.BindingObjectAlternate.toLowerCase().trim();
                    Schema.DescribeSobjectResult[] results = Schema.describeSObjects(new String[] { bindingObjectApiName });
                    if(results.size() != 1) {
                        throw new InjectorException('Failed to find SObject ' + bindingObjectApiName + ' referenced by binding ' + bindingConfig.DeveloperName);
                    }
                    bind(results[0].getSObjectType()); 
                }
                if(bindingConfig.BindingSequence != null) {
                    sequence(Integer.valueOf(bindingConfig.BindingSequence));
                }
                data(bindingConfig);
                to(bindingConfig.To);
            }
        }
    }

    public class InjectorException extends Exception {}
}
```


File `classes\di_InjectorComponentController.cls`:
```apex


public with sharing class di_InjectorComponentController {

    public String BindingNameValue {set; get;}
    
    public String BindingIdValue {set; get;}
    public Object ParametersValue {set; get;}

    public ApexPages.Component getInject() {
        ApexPages.Component cmp = null;
        di_Binding bindingInfo = getBinding(BindingNameValue);
        switch on bindingInfo.BindingType {
            when Flow {
                cmp = (ApexPages.Component) getInjectorFlowProxyInstance((String) bindingInfo.To, ParametersValue);
            }
            when else {
                cmp = (ApexPages.Component) di_Injector.Org.getInstance(BindingNameValue, ParametersValue);
            }
        }
        return cmp;
    }

    public static di_Binding getBinding(String bindingName) {
        return di_Injector.Org.Bindings.byName(bindingName).get()[0];
    }

    
    
    
    @testVisible
    private Object getInjectorFlowProxyInstance(String flowName, Object params) {
        return new Component.di_injectorFlowProxy(
            flowName = flowName,
            inputVariables = params
            );
    }

}```


File `classes\di_InjectorComponentFlowProxyController.cls`:
```apex


public with sharing class di_InjectorComponentFlowProxyController {

    public String FlowNameValue { get; set; }

    public Object InputVariablesValue { get; set; }

    public Component.Flow.Interview getInject() {

        Component.Flow.Interview interview = new Component.Flow.Interview();
        interview.name = FlowNameValue;

        
        
        
        
        
        
        
        
        
        
        

        if ( InputVariablesValue instanceof Map<Object, Object> ) {
            
            Map<Object, Object> oldMap = (Map<Object, Object>) InputVariablesValue;
            Map<String, Object> newMap = new Map<String, Object>();
            for ( Object key : oldMap.keySet() ) {
                newMap.put( String.valueOf( key ), oldMap.get( key ) );
            }
            di_BindingParam.parameters = newMap;
        } else if ( InputVariablesValue instanceof Map<String, Object> ) {
            di_BindingParam.parameters = (Map<String, Object>) InputVariablesValue;
        }

        return interview;
    }

}```


File `classes\di_InjectorController.cls`:
```apex


public with sharing class di_InjectorController {

    public ApexPages.StandardController StandardController {get;set;}

    public di_InjectorController(ApexPages.StandardController StandardController) {
        this.StandardController = StandardController;
    }

    public di_InjectorController getThis() {
        return this;
    }

    @AuraEnabled
    public static di_Binding getBinding(String bindingName) {
        return di_Injector.Org.Bindings.byName(bindingName).get()[0];
    }
}
```


File `classes\di_Module.cls`:
```apex



public virtual class di_Module {

    private List<di_Binding> bindings = new List<di_Binding>();
    private di_Binding.BindingType bindingType;
    private String developerName;
    private SObjectType bindingObject;
    private Integer bindingSequence;
    private Object to;
    private Object bindingData;

    
    public di_Module() {
        init();
    }

    
    public virtual void configure() { }

    
    public di_Module type(String value) {
        List<di_Binding.BindingType> bindEnumValues = di_Binding.BindingType.values();
        for(di_Binding.BindingType bindEnumValue : bindEnumValues) {
            if(bindEnumValue.name().equals(value)) {
                bindingType = bindEnumValue;
                return this;
            }
        }
        throw new ModuleException('Binding type ' + value + ' is not valid.');
    }

    
    public di_Module type(di_Binding.BindingType value) {
        bindingType = value;
        return this;
    }

    
    public di_Module apex() {
        bindingType = di_Binding.BindingType.Apex;
        return this;
    }

    
    public di_Module lightningComponent() {
        bindingType = di_Binding.BindingType.LightningComponent;
        return this;
    }

    
    public di_Module visualforceComponent() {
        bindingType = di_Binding.BindingType.VisualforceComponent;
        return this;
    }

    
    public di_Module flow() {
        bindingType = di_Binding.BindingType.Flow;
        return this;
    }

    
    public di_Module module() {
        bindingType = di_Binding.BindingType.Module;
        return this;
    }

    
    public di_Module bind(Type bindingType) {
        developerName = bindingType.getName();
        return this;
    }

    
    public di_Module bind(SObjectType sObjectType) {
        bindingObject = sObjectType;
        return this;
    }

    
    public di_Module bind(String bindingName) {
        developerName = bindingName;
        return this;
    }

    
    public di_Module sequence(Integer sequence) {
        bindingSequence = sequence;
        return this;
    }

    
    public di_Module data(Object data) {
        bindingData = data;
        return this;
    }

    
    public di_Module to(String bindingTo) {
        return toObject(bindingTo);
    }

    
    public di_Module to(Type bindingTo) {
        return toObject(bindingTo.getName());
    }

    
    public di_Module toObject(Object to) {
        
        this.to = to;
        
        if(to instanceof di_Flow) {
            return flow().addBinding();
        }
        return addBinding();
    }

    
    public List<di_Binding> getBindings() {
        
        return this.bindings;
    }

    private di_Module addBinding() {
        
        di_Binding newBinding = di_Binding.newInstance(
            bindingType,
            developerName,
            bindingObject,
            bindingSequence,
            to,
            bindingData);
            
        bindings.add(newBinding);

        di_PlatformCache.getInstance().addBindingToPlatformCache( newBinding );

        init();
        return this;
    }

    private void init() {
        
        bindingType = di_Binding.BindingType.Apex;
        developerName = null;
        bindingObject = null;
        bindingSequence = null;
        to = null;
    }

    public class ModuleException extends Exception {}
}```


File `classes\di_NamespaceClass.cls`:
```apex
public without sharing class di_NamespaceClass 
{
    public static final String CURRENTNAMESPACE = di_NamespaceClass.class.getName().substringBefore('.');
}
```


File `classes\di_PlatformCache.cls`:
```apex
public with sharing class di_PlatformCache
{

    public static final Integer NUM_OF_SECS_IN24HR =  86400;

    @TestVisible
    private static final String BINDING_KEY = 'bindingKeyIndex';
    @TestVisible
    private static di_PlatformCache instance;
    @TestVisible
    private Map<String, Map<Schema.SObjectType, Set<String> > > cacheKeyIndexMap = new Map<String, Map<Schema.SObjectType, Set<String> > >();
    @TestVisible
    private static Map<String, String> generatedKeyNames = new Map<String, String>();

    @TestVisible
    private static Boolean DEBUGGING = false;

    private di_PlatformCache()
    {
    }

    public static di_PlatformCache getInstance()
    {
        if ( instance == null )
        {
            instance = new di_PlatformCache();
        }

        return instance;
    }

    public static Boolean isStoringBindingInPlatformCache()
    {
        return getConfig().UsePlatformCacheToStoreBindings__c == null ? false : ( getConfig().UsePlatformCacheToStoreBindings__c && getPartition() != null );
    }

    public Map<String, Map<Schema.SObjectType, Set<String>>> getCacheKeyIndexMap()
    {
        if ( cacheKeyIndexMap.isEmpty() )
        {
            try
            {

                Cache.OrgPartition orgPartition = getPartition();
                if ( orgPartition != null )
                {
                    cacheKeyIndexMap = (Map<String, Map<Schema.SObjectType, Set<String> > >) orgPartition.get( getKeyIndexName() );
                }
            }
            catch (Cache.Org.OrgCacheException ex)
            {

                cacheKeyIndexMap = null;
            }

            if ( cacheKeyIndexMap == null )
            {
                cacheKeyIndexMap = new Map<String, Map<Schema.SObjectType, Set<String> > >();
            }
        }

        return cacheKeyIndexMap;
    }

    public Boolean addBindingToPlatformCache( di_Binding binding )
    {
        Boolean result = false;
        if ( isStoringBindingInPlatformCache() )
        {

            Cache.OrgPartition orgPartition = getPartition();
            if ( orgPartition != null )
            {
                String theKeyName = getKeyName(binding);

                List<di_Binding> workingBindings = new List<di_Binding>();

                if ( orgPartition.contains(theKeyName) )
                {

                    workingBindings.addAll((List<di_Binding>) orgPartition.get(theKeyName));
                }

                workingBindings.add( binding );
                log('Adding binding for hash => ' + theKeyName + ' && developerName => ' + binding.developerName + ' && object => ' + binding.bindingObject);

                try
                {
                    orgPartition.put(theKeyName, workingBindings, getPartitionTTL(), Cache.Visibility.ALL, false);
                }
                catch (cache.Org.OrgCacheException oce)
                {

                    log( oce );
                }

                addBindingToKeyIndex(binding);

                result = true;
            }
        }
        return result;
    }

    public list<di_Binding> retrieveBindings(String developerName, Schema.SObjectType bindingSObjectType)
    {
        list<di_Binding> bindings = new list<di_Binding>();

        if ( isStoringBindingInPlatformCache()
             && string.isNotBlank(developerName)
             && bindingSObjectType != null)
        {
            log('Retrieving from Cache Key => ' + developerName + ' && Cache Key Index => ' + bindingSObjectType);

            Cache.OrgPartition orgPartition = getPartition();
            Map<Schema.SObjectType, Set<String> > keyIndexBySObjectTypeMap = getCacheKeyIndexMap().get(developerName.toLowerCase().trim());
            if ( keyIndexBySObjectTypeMap != null && orgPartition != null )
            {
                Set<String> cacheKeys = keyIndexBySObjectTypeMap.get(bindingSObjectType);
                if ( cacheKeys != null )
                {
                    Object cachedObject = null;
                    for ( String cacheKey : cacheKeys )
                    {
                        cachedObject = orgPartition.get( cacheKey );
                        if ( cachedObject != null )
                        {
                            bindings.addAll( (List<di_Binding>) cachedObject);
                        }
                    }
                }
            }
        }

        return bindings;
    }

    public static void clearCachedBindings() {

        Set<String> keys = getPartitionKeys();

        if ( keys != null )
        {
            String partitionKey = getPartitionName();
            Cache.OrgPartition partition = getPartition();

            for (String key : partition.getKeys() )
            {
                try
                {
                    partition.remove(key);
                }
                catch (Exception ex)
                {
                    log('XX]> Unable to remove Platform Cache partition [' + partitionKey + '] key [' + key + ']');
                }
            }
        }
    }

    public static Set<String> getPartitionKeys()
    {
        Set<String> keys = null;
        Cache.OrgPartition partition = getPartition();
        if ( partition != null )
        {

            keys = partition.getKeys();
        }
        return keys;
    }

    @TestVisible
    private static di_Configurations__c getConfig()
    {
        di_Configurations__c config = di_Configurations__c.getInstance();

        if ( config == null )
        {
            config = new di_Configurations__c();
            config.SetupOwnerId = ConnectApi.Organization.getSettings().orgId;

            if (di_Configurations__c.SObjectType.getDescribe().isCreateable() )
            {
                insert config;
            }
        }

        return config;
    }

    @TestVisible
    private static String getPartitionName()
    {
        return getConfig().OrgCachePartitionName__c;
    }

    @TestVisible
    private Integer getPartitionTTL()
    {
        return NUM_OF_SECS_IN24HR;
    }

    @TestVisible
    private static Cache.OrgPartition getPartition()
    {
        Cache.OrgPartition result = null;
        try
        {
            result = Cache.Org.getPartition( getPartitionName() );
        }
        catch (Exception excp)
        {
            log('ERROR: Is there Cache? Is the Cache Partition enabled : Exception:' + excp);
        }
        return result;
    }

    @TestVisible
    private boolean pushCacheKeyIndexMapToCache()
    {

        Cache.OrgPartition orgPartition = getPartition();
        if ( orgPartition != null )
        {
            orgPartition.put( getKeyIndexName(), this.cacheKeyIndexMap, getPartitionTTL(), Cache.Visibility.ALL, false);

        }
        return orgPartition != null;
    }

    @TestVisible
    private void addBindingToKeyIndex(di_Binding binding)
    {
        if (binding == null) {
            return;
        }
        String workingDeveloperName = binding.developerName.toLowerCase().trim();

        if ( !getCacheKeyIndexMap().containsKey( workingDeveloperName ) )
        {
            getCacheKeyIndexMap().put(workingDeveloperName, new Map<Schema.SObjectType, Set<String> >() );
        }

        if ( !getCacheKeyIndexMap().get(workingDeveloperName).containsKey( binding.bindingObject) )
        {
            getCacheKeyIndexMap().get(workingDeveloperName).put( binding.bindingObject, new Set<String>() );
        }

        getCacheKeyIndexMap().get(workingDeveloperName).get(binding.bindingObject).add(getKeyName(binding));

        pushCacheKeyIndexMapToCache();
    }

    @TestVisible
    private String constructKeyName( Schema.SObjectType bindingSObjectType, String developerName )
    {
        if (String.isBlank(developerName)) {
            return null;
        }
        String key = ( ( bindingSObjectType != null ) ? bindingSObjectType.getDescribe().getName().toLowerCase().replaceAll('__','') : '' )
                     + ( String.isBlank(developerName) ? '' : developerName.toLowerCase().trim() );

        if (generatedKeyNames.containsKey(key))
        {
            return generatedKeyNames.get(key);
        }

        String hash = String.valueOf( Math.abs( ( key ).hashcode() ) );
        log('Creating Hash For => ' + developerName + ' && ' + bindingSObjectType + ' := ' + hash);
        generatedKeyNames.put(key, hash);
        return hash;
    }

    @TestVisible
    private String getKeyName( String developerName, Schema.SObjectType bindingSObjectType)
    {
        return constructKeyName( bindingSObjectType, developerName);
    }

    @TestVisible
    private String getKeyName( di_Binding binding )
    {
        return constructKeyName( binding.bindingObject, binding.developerName);
    }

    @TestVisible
    private String getKeyIndexName()
    {
        return di_PlatformCache.BINDING_KEY;
    }

    @TestVisible
    private static Boolean log(Exception excp)
    {
        Boolean before = DEBUGGING, result;

        DEBUGGING = true;
        result = log('Exception: ' + excp.getMessage());
        DEBUGGING = before;
        return result;

    }

    @TestVisible
    private static Boolean log(String message)
    {
        Boolean doLog = DEBUGGING && string.isNotBlank(message);
        if ( doLog )
        {
            system.debug('+++ di_PlatformCache.message: ' + message);
        }
        return doLog;
    }
}```
