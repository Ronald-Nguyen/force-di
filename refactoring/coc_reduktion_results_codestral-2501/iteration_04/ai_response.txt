I'll refactor the code to reduce cognitive complexity while preserving behavior. Here are the refactored files:

File `main\classes\di_Binding.cls`:
```apex
public abstract class di_Binding implements Comparable {

    public BindingType BindingType {get; private set;}

    @AuraEnabled
    public String BindingTypeAsString {get { return BindingType.name();} }

    @AuraEnabled
    public String NamespacePrefix {get;private set;}

    @AuraEnabled
    public String DeveloperName {get;private set;}

    @AuraEnabled
    public SObjectType BindingObject {get;private set;}

    @AuraEnabled
    public Integer BindingSequence {get;private set;}

    @AuraEnabled
    public Object To {get;private set;}

    @AuraEnabled
    public Object Data {get;private set;}

    private Boolean IsProvider = false;
    private Object Injected = null;

    public Object getInstance() {
        return getInstance(null, false);
    }

    public Object getInstance(Object params) {
        return getInstance(params, false);
    }

    public Object getInstance(Object params, Boolean newInstance) {
        if(IsProvider) {
            return newInstance(params);
        }
        if(newInstance) {
            return newInstance(params);
        }
        if(Injected == null) {
            Injected = newInstance(params);
        }
        return Injected;
    }

    public abstract Object newInstance(Object params);

    public Integer compareTo(Object compareTo) {
        di_Binding binding = (di_Binding) compareTo;
        return this.toString().compareTo(binding.toString());
    }

    public override String toString() {
        String hashValue = (BindingObject != null) ?
            BindingObject.getDescribe().getName() :
            DeveloperName;

        if(BindingSequence != null) {
            hashValue += '#' + String.valueOf(BindingSequence).leftPad(4,'0');
        }
        return hashValue;
    }

    public interface Provider {
        Object newInstance(Object params);
    }

    public class Resolver {

        private String developerName;
        private SObjectType bindingObject;
        private boolean bindingsAreRequired = true;

        private List<di_Module> modules = null;

        private List<di_Binding> bindings = null;

        public Resolver(List<di_Module> modules) {
            this.modules = modules;
        }

        public Resolver set(di_Module module) {
            modules.clear();
            modules.add(module);

            bindings = null;
            return this;
        }

        public Resolver add(di_Module module) {
            modules.add(module);

            bindings = null;
            return this;
        }

        public Resolver byName(String developerName) {
            this.developerName = developerName;
            return this;
        }

        public Resolver bySObject(SObjectType bindingObject) {
            this.bindingObject = bindingObject;
            return this;
        }

        public Resolver emptyBindingsAllowed() {
            bindingsAreRequired = false;
            return this;
        }

        public Resolver replaceBindingWith(Object mockType) {
            loadBindings();

            for (Integer currentBindingsIndex = 0; currentBindingsIndex < this.bindings.size(); currentBindingsIndex++) {
                if (isBindingMatchByFilteringCriteria(this.bindings[currentBindingsIndex])) {
                    this.bindings[currentBindingsIndex] = di_Binding.newInstance(
                        di_Binding.BindingType.Apex,
                        this.developerName,
                        this.bindingObject,
                        null,
                        mockType,
                        null
                    );
                    break;
                }
            }

            this.developerName = null;
            this.bindingObject = null;

            return this;
        }

        private Boolean isBindingMatchByFilteringCriteria(di_Binding bind) {
            Boolean isMatch = false;

            if (String.isNotBlank(this.developerName) && this.bindingObject != null) {
                if (isDeveloperNameMatch(bind) && this.bindingObject == bind.BindingObject) {
                    isMatch = true;
                }
            } else {
                if (String.isNotBlank(this.developerName) && isDeveloperNameMatch(bind)) {
                    isMatch = true;
                } else if (this.bindingObject != null && bind.BindingObject == this.bindingObject) {
                    isMatch = true;
                }
            }

            return isMatch;
        }

        private Boolean isDeveloperNameMatch(di_Binding bind) {
            return this.developerName.equalsIgnoreCase(bind.DeveloperName) ||
                   this.developerName.equalsIgnoreCase(di_NamespaceClass.CURRENTNAMESPACE + '.' + bind.DeveloperName);
        }

        private void loadBindings() {
            if (this.bindings == null) {
                this.bindings = new List<di_Binding>();
                for (di_Module module : modules) {
                    module.configure();
                    for(di_Binding bind : module.getBindings()) {
                        if(bind.BindingType == di_Binding.BindingType.Module) {
                            di_Module embeddedModule = (di_Module) bind.getInstance();
                            embeddedModule.configure();
                            this.bindings.addAll(embeddedModule.getBindings());
                        } else {
                            this.bindings.add(bind);
                        }
                    }
                }
            }
        }

        public List<di_Binding> get() {
            list<di_Binding> matchedBindings = di_PlatformCache.getInstance().retrieveBindings(this.developerName, this.bindingObject);

            if ((di_PlatformCache.isStoringBindingInPlatformCache() && bindingsAreRequired && matchedBindings.isEmpty()) ||
                !di_PlatformCache.isStoringBindingInPlatformCache()) {

                loadBindings();

                for (di_Binding bind : bindings) {
                    if (isBindingMatchByFilteringCriteria(bind)) {
                        matchedBindings.add(bind);
                    }
                }
            }

            this.developerName = null;
            this.bindingObject = null;
            matchedBindings.sort();

            this.bindingsAreRequired = true;

            return matchedBindings;
        }
    }

    public class BindingException extends Exception {}

    public enum BindingType { Apex, VisualforceComponent, LightningComponent, Flow, Module }

    public static di_Binding newInstance(
            BindingType bindType,
            String developerName,
            SObjectType bindingObject,
            Integer bindingSequence,
            Object to,
            Object bindingData) {

        Type implType = BINDING_IMPLS_BY_TYPE.get(bindType);

        if (implType != null) {
            di_Binding binding = (di_Binding) implType.newInstance();
            binding.BindingType = bindType;
            binding.DeveloperName = developerName;
            binding.BindingObject = bindingObject;
            binding.BindingSequence = bindingSequence;
            binding.To = to;
            binding.Data = bindingData;
            return binding;
        }
        throw new BindingException('Binding type ' + bindType + ' has no implementation.');
    }

    private static final Map<BindingType, Type> BINDING_IMPLS_BY_TYPE =
        new Map<BindingType, Type> {
            BindingType.Apex => ApexBinding.class,
            BindingType.LightningComponent => LightningComponentBinding.class,
            BindingType.VisualforceComponent => VisualForceComponentBinding.class,
            BindingType.Flow => FlowBinding.class,
            BindingType.Module => ApexBinding.class
        };

    private class ApexBinding extends di_Binding {
        public override Object newInstance(Object params) {
            if (To instanceof String) {
                String className = (String) To;
                Type toType = NameSpacePrefix == null ? Type.forName(className) : Type.forName(NamespacePrefix, className);
                if (toType == null) {
                    throw new BindingException('Apex binding ' + DeveloperName + ' implementation ' + To + ' does not exist');
                }
                Object toObject = toType.newInstance();

                IsProvider = toObject instanceof Provider;
                if (IsProvider) {
                    return ((Provider) toObject).newInstance(params);
                } else if (params != null) {
                    throw new BindingException('Apex binding ' + DeveloperName + ' implementation ' + className + ' does not implement the Provider interface.');
                }
                return toObject;
            }

            return To;
        }
    }

    private class VisualForceComponentBinding extends di_Binding {
        public override Object newInstance(Object params) {
            if (To instanceof String) {
                String className = (String) To;
                Type toType = NamespacePrefix == null ? Type.forName(className) : Type.forName(NamespacePrefix, className);
                if (toType == null) {
                    throw new BindingException('Visualforce Component binding ' + DeveloperName + ' implementation ' + className + ' does not exist.');
                }

                Object toObject = toType.newInstance();
                IsProvider = toObject instanceof Provider;
                if (IsProvider) {
                    return ((Provider) toObject).newInstance(params);
                }
                throw new BindingException('Visualforce Component binding ' + DeveloperName + ' must point to a class implementing the Provider interface.');
            }

            return To;
        }
    }

    private class LightningComponentBinding extends di_Binding {
        public override Object newInstance(Object params) {
            return To;
        }
    }

    private class FlowBinding extends di_Binding {
        public override Object newInstance(Object params) {
            if (To instanceof String) {
                String flowName = (String) To;
                if (params instanceof Map<String, Object>) {
                    return new di_Flow(Flow.Interview.createInterview(flowName, (Map<String, Object>) params));
                }
                return new di_Flow(Flow.Interview.createInterview(flowName, new Map<String, Object>()));
            }

            return To;
        }
    }
}
```

File `main\classes\di_BindingParam.cls`:
```apex
public with sharing class di_BindingParam {

    public static Map<String, Object> parameters { get; set; }

    @InvocableMethod(
        label = 'Get Value'
    )
    public static List<Response> invoke(List<Request> requests) {
        List<Response> responses = new List<Response>();

        for (Request req : requests) {
            Response res = new Response();

            if (parameters != null) {
                Object value = parameters.get(req.paramName);

                if (value != null) {
                    processValue(value, res);

                    setDefaultValues(res);

                    responses.add(res);
                } else {
                    System.debug(LoggingLevel.WARN, 'BindingParam.parameters.get("' + req + '") is null');
                }
            } else {
                System.debug(LoggingLevel.WARN, 'BindingParam.parameters is null');
            }

            System.debug('paramName=' + req);
            System.debug(res);
        }

        return responses;
    }

    private static void processValue(Object value, Response res) {
        if (value instanceof Decimal) {
            processDecimalValue((Decimal) value, res);
        } else if (value instanceof Decimal[]) {
            processDecimalArrayValue((Decimal[]) value, res);
        } else if (value instanceof String) {
            processStringValue((String) value, res);
        } else if (value instanceof String[]) {
            processStringArrayValue((String[]) value, res);
        } else if (value instanceof Boolean) {
            processBooleanValue((Boolean) value, res);
        } else if (value instanceof Boolean[]) {
            processBooleanArrayValue((Boolean[]) value, res);
        } else if (value instanceof Date) {
            processDateValue((Date) value, res);
        } else if (value instanceof Date[]) {
            processDateArrayValue((Date[]) value, res);
        } else if (value instanceof DateTime) {
            processDateTimeValue((DateTime) value, res);
        } else if (value instanceof DateTime[]) {
            processDateTimeArrayValue((DateTime[]) value, res);
        }
    }

    private static void processDecimalValue(Decimal decimalValue, Response res) {
        res.longValue = toLongValue(decimalValue);
        res.decimalValue = decimalValue;
        res.stringValue = toStringValue(decimalValue);
        res.booleanValue = toBooleanValue(decimalValue);
        res.dateValue = toDateValue(decimalValue);
        res.dateTimeValue = toDateTimeValue(decimalValue);
    }

    private static void processDecimalArrayValue(Decimal[] decimalValues, Response res) {
        res.decimalValues = decimalValues;
        for (Decimal decimalValue : decimalValues) {
            res.longValues.add(toLongValue(decimalValue));
            res.stringValues.add(toStringValue(decimalValue));
            res.booleanValues.add(toBooleanValue(decimalValue));
            res.dateValues.add(toDateValue(decimalValue));
            res.dateTimeValues.add(toDateTimeValue(decimalValue));
        }
    }

    private static void processStringValue(String stringValue, Response res) {
        res.longValue = toLongValue(stringValue);
        res.decimalValue = toDecimalValue(stringValue);
        res.stringValue = stringValue;
        res.booleanValue = toBooleanValue(stringValue);
        res.dateValue = toDateValue(stringValue);
        res.dateTimeValue = toDateTimeValue(stringValue);
    }

    private static void processStringArrayValue(String[] stringValues, Response res) {
        res.stringValues = stringValues;
        for (String stringValue : stringValues) {
            res.longValues.add(toLongValue(stringValue));
            res.decimalValues.add(toDecimalValue(stringValue));
            res.booleanValues.add(toBooleanValue(stringValue));
            res.dateValues.add(toDateValue(stringValue));
            res.dateTimeValues.add(toDateTimeValue(stringValue));
        }
    }

    private static void processBooleanValue(Boolean booleanValue, Response res) {
        res.longValue = toLongValue(booleanValue);
        res.decimalValue = toDecimalValue(booleanValue);
        res.stringValue = toStringValue(booleanValue);
        res.booleanValue = booleanValue;
        res.dateValue = toDateValue(booleanValue);
        res.dateTimeValue = toDateTimeValue(booleanValue);
    }

    private static void processBooleanArrayValue(Boolean[] booleanValues, Response res) {
        res.booleanValues = booleanValues;
        for (Boolean booleanValue : booleanValues) {
            res.longValues.add(toLongValue(booleanValue));
            res.decimalValues.add(toDecimalValue(booleanValue));
            res.stringValues.add(toStringValue(booleanValue));
            res.dateValues.add(toDateValue(booleanValue));
            res.dateTimeValues.add(toDateTimeValue(booleanValue));
        }
    }

    private static void processDateValue(Date dateValue, Response res) {
        res.longValue = toLongValue(dateValue);
        res.decimalValue = toDecimalValue(dateValue);
        res.stringValue = toStringValue(dateValue);
        res.booleanValue = toBooleanValue(dateValue);
        res.dateValue = dateValue;
        res.dateTimeValue = toDateTimeValue(dateValue);
    }

    private static void processDateArrayValue(Date[] dateValues, Response res) {
        res.dateValues = dateValues;
        for (Date dateValue : dateValues) {
            res.longValues.add(toLongValue(dateValue));
            res.decimalValues.add(toDecimalValue(dateValue));
            res.stringValues.add(toStringValue(dateValue));
            res.booleanValues.add(toBooleanValue(dateValue));
            res.dateTimeValues.add(toDateTimeValue(dateValue));
        }
    }

    private static void processDateTimeValue(DateTime dateTimeValue, Response res) {
        res.longValue = toLongValue(dateTimeValue);
        res.decimalValue = toDecimalValue(dateTimeValue);
        res.stringValue = toStringValue(dateTimeValue);
        res.booleanValue = toBooleanValue(dateTimeValue);
        res.dateValue = toDateValue(dateTimeValue);
        res.dateTimeValue = dateTimeValue;
    }

    private static void processDateTimeArrayValue(DateTime[] dateTimeValues, Response res) {
        res.dateTimeValues = dateTimeValues;
        for (DateTime dateTimeValue : dateTimeValues) {
            res.longValues.add(toLongValue(dateTimeValue));
            res.decimalValues.add(toDecimalValue(dateTimeValue));
            res.stringValues.add(toStringValue(dateTimeValue));
            res.booleanValues.add(toBooleanValue(dateTimeValue));
            res.dateValues.add(toDateValue(dateTimeValue));
        }
    }

    private static void setDefaultValues(Response res) {
        if (res.longValue == null && !res.longValues.isEmpty()) {
            res.longValue = res.longValues[0];
        }
        if (res.decimalValue == null && !res.decimalValues.isEmpty()) {
            res.decimalValue = res.decimalValues[0];
        }
        if (res.stringValue == null && !res.stringValues.isEmpty()) {
            res.stringValue = res.stringValues[0];
        }
        if (res.booleanValue == null && !res.booleanValues.isEmpty()) {
            res.booleanValue = res.booleanValues[0];
        }
        if (res.dateValue == null && !res.dateValues.isEmpty()) {
            res.dateValue = res.dateValues[0];
        }
        if (res.dateTimeValue == null && !res.dateTimeValues.isEmpty()) {
            res.dateTimeValue = res.dateTimeValues[0];
        }

        if (res.longValue != null && res.longValues.isEmpty()) {
            res.longValues.add(res.longValue);
        }
        if (res.decimalValue != null && res.decimalValues.isEmpty()) {
            res.decimalValues.add(res.decimalValue);
        }
        if (res.stringValue != null && res.stringValues.isEmpty()) {
            res.stringValues.add(res.stringValue);
        }
        if (res.booleanValue != null && res.booleanValues.isEmpty()) {
            res.booleanValues.add(res.booleanValue);
        }
        if (res.dateValue != null && res.dateValues.isEmpty()) {
            res.dateValues.add(res.dateValue);
        }
        if (res.dateTimeValue != null && res.dateTimeValues.isEmpty()) {
            res.dateTimeValues.add(res.dateTimeValue);
        }
    }

    private static Long toLongValue(Decimal value) {
        return (value == null ? null : value.longValue());
    }

    private static Long toLongValue(String value) {
        return ((value == null || !value.isNumeric()) ? null : Long.valueOf(value));
    }

    private static Long toLongValue(Boolean value) {
        return (value == null ? null : value ? 1 : 0);
    }

    private static Long toLongValue(Date value) {
        return (value == null ? null : toLongValue(
            DateTime.newInstance(value.year(), value.month(), value.day(), 0, 0, 0)
        ));
    }

    private static Long toLongValue(DateTime value) {
        return (value == null ? null : value.getTime());
    }

    private static Decimal toDecimalValue(String value) {
        return ((value == null || !value.isNumeric()) ? null : Decimal.valueOf(value));
    }

    private static Decimal toDecimalValue(Boolean value) {
        return (value == null ? null : value ? 1 : 0);
    }

    private static Decimal toDecimalValue(Date value) {
        return (value == null ? null : toDecimalValue(
            DateTime.newInstance(value.year(), value.month(), value.day(), 0, 0, 0)
        ));
    }

    private static Decimal toDecimalValue(DateTime value) {
        return (value == null ? null : value.getTime());
    }

    private static String toStringValue(Date value) {
        return (value == null ? null : String.valueOf(value));
    }

    private static String toStringValue(DateTime value) {
        return (value == null ? null : String.valueOf(value));
    }

    private static String toStringValue(Object value) {
        return (value == null ? null : String.valueOf(value));
    }

    private static Boolean toBooleanValue(Decimal value) {
        return (value == null ? false : (value > 0));
    }

    private static Boolean toBooleanValue(String value) {
        return (value == null ? false : Boolean.valueOf(value));
    }

    private static Boolean toBooleanValue(Date value) {
        return (value == null ? false : true);
    }

    private static Boolean toBooleanValue(DateTime value) {
        return (value == null ? false : true);
    }

    private static Date toDateValue(Decimal value) {
        return (value == null ? null : DateTime.newInstance(value.longValue()).date());
    }

    private static Date toDateValue(String value) {
        try {
            return (value == null ? null : Date.valueOf(value));
        } catch (Exception e) {
            return null;
        }
    }

    private static Date toDateValue(Boolean value) {
        return null;
    }

    private static Date toDateValue(DateTime value) {
        return (value == null ? null : value.date());
    }

    private static DateTime toDateTimeValue(Decimal value) {
        return (value == null ? null : DateTime.newInstance(value.longValue()));
    }

    private static DateTime toDateTimeValue(String value) {
        try {
            return (value == null ? null : DateTime.valueOf(value));
        } catch (Exception e) {
            return toDateValue(value);
        }
    }

    private static DateTime toDateTimeValue(Boolean value) {
        return null;
    }

    private static DateTime toDateTimeValue(Date value) {
        return (value == null ? null : DateTime.newInstance(value.year(), value.month(), value.day(), 0, 0, 0));
    }

    public class Request {
        @InvocableVariable(
            label = 'Parameter Name'
            required = true
        )
        public String paramName;
    }

    public class Response {
        @InvocableVariable(
            label = 'Number'
            description = 'Whole number (no decimals)'
        )
        public Long longValue;

        @InvocableVariable(
            label = 'Decimal'
            description = 'Number that may include decimal places'
        )
        public Decimal decimalValue;

        @InvocableVariable(
            label = 'Text'
            description = 'Text value'
        )
        public String stringValue;

        @InvocableVariable(
            label = 'Boolean'
            description = 'true/false'
        )
        public Boolean booleanValue;

        @InvocableVariable(
            label = 'Date'
        )
        public Date dateValue;

        @InvocableVariable(
            label = 'Date/Time'
        )
        public DateTime dateTimeValue;

        @InvocableVariable(
            label = 'Number Collection'
            description = 'Collection of whole numbers'
        )
        public Long[] longValues = new Long[] {};

        @InvocableVariable(
            label = 'Decimal Collection'
            description = 'Collection of numbers that may include decimal places'
        )
        public Decimal[] decimalValues = new Decimal[] {};

        @InvocableVariable(
            label = 'Text Collection'
            description = 'Collection of text values'
        )
        public String[] stringValues = new String[] {};

        @InvocableVariable(
            label = 'Boolean Collection'
            description = 'Collection of true/false values'
        )
        public Boolean[] booleanValues = new Boolean[] {};

        @InvocableVariable(
            label = 'Date Collection'
            description = 'Collection of date values'
        )
        public Date[] dateValues = new Date[] {};

        @InvocableVariable(
            label = 'Date/Time Collection'
            description = 'Collection of date/time values'
        )
        public DateTime[] dateTimeValues = new DateTime[] {};
    }
}
```

File `main\classes\di_Injector.cls`:
```apex
public class di_Injector {
    @testVisible
    private static List<di_BindingConfigWrapper> mock_BindingConfigurationWrappersOuter = null;

    public static final di_Injector Org =
        new di_Injector(
            new List<di_Module> {
        new CustomMetadataModule()
    });

    @TestVisible
    public di_Binding.Resolver Bindings {get; private set;}

    public di_Injector(di_Module module) {
        this(new List<di_Module> { module });
    }

    public di_Injector(List<di_Module> modules) {
        Bindings = new di_Binding.Resolver(modules);
    }

    public Object getInstance(Type developerNameByType) {
        return getInstance(developerNameByType?.getName()?.toLowerCase(), null);
    }

    public Object getInstance(Type developerNameByType, Object params) {
        return getInstance(developerNameByType?.getName()?.toLowerCase(), params);
    }

    public Object getInstance(String developerName) {
        return getInstance(developerName, null);
    }

    public Object getInstance(String developerName, Object params) {
        if (String.isBlank(developerName)) {
            throw new InjectorException('Request for Binding cannot take "developerName" parameter of null');
        }

        List<di_Binding> bindingsFound = this.Bindings.byName(developerName.toLowerCase().trim()).get();
        if (bindingsFound == null || bindingsFound.isEmpty()) {
            throw new InjectorException('Binding for "' + developerName + '" not found');
        }
        return bindingsFound[0].getInstance(params);
    }

    public Object getInstance(Type developerNameByType, Schema.SObjectType bindingSObjectType) {
        return getInstance(developerNameByType, bindingSObjectType, null);
    }

    public Object getInstance(Type developerNameByType, Schema.SObjectType bindingSObjectType, Object params) {
        return getInstance(developerNameByType == null ? null : developerNameByType.getName().toLowerCase(), bindingSObjectType, params);
    }

    public Object getInstance(String developerName, Schema.SObjectType bindingSObjectType, Object params) {
        if (String.isBlank(developerName)) {
            throw new InjectorException('Request for Binding cannot take "developerName" parameter of null');
        }

        if (bindingSObjectType == null) {
            throw new InjectorException('Request for Binding cannot take "bindingSObjectType" parameter of null');
        }

        List<di_Binding> bindingsFound = this.Bindings.bySObject(bindingSObjectType)
                                         .byName(developerName.toLowerCase().trim())
                                         .get();

        if (bindingsFound == null || bindingsFound.isEmpty() || bindingsFound[0] == null) {
            throw new InjectorException('Binding for "' + developerName + '" and SObjectType "' + bindingSObjectType + '" not found');
        }
        return bindingsFound[0].getInstance(params);
    }

    @testVisible
    private class CustomMetadataModule extends di_Module {
        private string bindingObjectApiName = null;

        @testVisible
        private List<di_BindingConfigWrapper> getDIBinding() {
            List<di_BindingConfigWrapper> recordList = new List<di_BindingConfigWrapper>();

            if(di_Injector.mock_BindingConfigurationWrappersOuter != null) {
                recordList = di_Injector.mock_BindingConfigurationWrappersOuter;
            } else {
                List<di_Binding__mdt> bindingMDTRec = [SELECT QualifiedAPIName
                                                            , DeveloperName
                                                            , BindingName__c
                                                            , NamespacePrefix
                                                            , Type__c
                                                            , To__c
                                                            , BindingObject__c
                                                            , BindingObject__r.QualifiedApiName
                                                            , BindingObjectAlternate__c
                                                            , BindingSequence__c
                                                         FROM di_Binding__mdt];
                for(di_Binding__mdt records :bindingMDTRec) {
                    recordList.add(new di_BindingConfigWrapper(records));
                }
            }
            return recordList;
        }

        public override void configure() {
            for(di_BindingConfigWrapper bindingConfig : getDIBinding()) {
                bind(bindingConfig.DeveloperName);
                type(bindingConfig.Type);

                if(String.isNotBlank(bindingConfig.BindingObject) || String.isNotBlank(bindingConfig.BindingObjectAlternate)) {
                    bindingObjectApiName = String.isNotBlank(bindingConfig.BindingObject)
                                            ? bindingConfig.bindingObjectQualifiedApiName.toLowerCase().trim()
                                            : bindingConfig.BindingObjectAlternate.toLowerCase().trim();

                    Schema.DescribeSobjectResult[] results = Schema.describeSObjects(new String[] { bindingObjectApiName });
                    if(results.size() != 1) {
                        throw new InjectorException('Failed to find SObject ' + bindingObjectApiName + ' referenced by binding ' + bindingConfig.DeveloperName);
                    }
                    bind(results[0].getSObjectType());
                }

                if(bindingConfig.BindingSequence != null) {
                    sequence(Integer.valueOf(bindingConfig.BindingSequence));
                }

                data(bindingConfig);
                to(bindingConfig.To);
            }
        }
    }

    public class InjectorException extends Exception {}
}
```

File `main\classes\di_Module.cls`:
```apex
public virtual class di_Module {

    private List<di_Binding> bindings = new List<di_Binding>();
    private di_Binding.BindingType bindingType;
    private String developerName;
    private SObjectType bindingObject;
    private Integer bindingSequence;
    private Object to;
    private Object bindingData;

    public di_Module() {
        init();
    }

    public virtual void configure() { }

    public di_Module type(String value) {
        List<di_Binding.BindingType> bindEnumValues = di_Binding.BindingType.values();
        for(di_Binding.BindingType bindEnumValue : bindEnumValues) {
            if(bindEnumValue.name().equals(value)) {
                bindingType = bindEnumValue;
                return this;
            }
        }
        throw new ModuleException('Binding type ' + value + ' is not valid.');
    }

    public di_Module type(di_Binding.BindingType value) {
        bindingType = value;
        return this;
    }

    public di_Module apex() {
        bindingType = di_Binding.BindingType.Apex;
        return this;
    }

    public di_Module lightningComponent() {
        bindingType = di_Binding.BindingType.LightningComponent;
        return this;
    }

    public di_Module visualforceComponent() {
        bindingType = di_Binding.BindingType.VisualforceComponent;
        return this;
    }

    public di_Module flow() {
        bindingType = di_Binding.BindingType.Flow;
        return this;
    }

    public di_Module module() {
        bindingType = di_Binding.BindingType.Module;
        return this;
    }

    public di_Module bind(Type bindingType) {
        developerName = bindingType.getName();
        return this;
    }

    public di_Module bind(SObjectType sObjectType) {
        bindingObject = sObjectType;
        return this;
    }

    public di_Module bind(String bindingName) {
        developerName = bindingName;
        return this;
    }

    public di_Module sequence(Integer sequence) {
        bindingSequence = sequence;
        return this;
    }

    public di_Module data(Object data) {
        bindingData = data;
        return this;
    }

    public di_Module to(String bindingTo) {
        return toObject(bindingTo);
    }

    public di_Module to(Type bindingTo) {
        return toObject(bindingTo.getName());
    }

    public di_Module toObject(Object to) {
        this.to = to;

        if(to instanceof di_Flow) {
            return flow().addBinding();
        }
        return addBinding();
    }

    public List<di_Binding> getBindings() {
        return this.bindings;
    }

    private di_Module addBinding() {
        di_Binding newBinding = di_Binding.newInstance(
            bindingType,
            developerName,
            bindingObject,
            bindingSequence,
            to,
            bindingData);

        bindings.add(newBinding);

        di_PlatformCache.getInstance().addBindingToPlatformCache(newBinding);

        init();
        return this;
    }

    private void init() {
        bindingType = di_Binding.BindingType.Apex;
        developerName = null;
        bindingObject = null;
        bindingSequence = null;
        to = null;
    }

    public class ModuleException extends Exception {}
}
```

File `main\classes\di_PlatformCache.cls`:
```apex
public with sharing class di_PlatformCache {
    public static final Integer NUM_OF_SECS_IN24HR = 86400;

    @TestVisible
    private static final String BINDING_KEY = 'bindingKeyIndex';
    @TestVisible
    private static di_PlatformCache instance;
    @TestVisible
    private Map<String, Map<Schema.SObjectType, Set<String>>> cacheKeyIndexMap = new Map<String, Map<Schema.SObjectType, Set<String>>>();
    @TestVisible
    private static Map<String, String> generatedKeyNames = new Map<String, String>();

    @TestVisible
    private static Boolean DEBUGGING = false;

    private di_PlatformCache() {
    }

    public static di_PlatformCache getInstance() {
        if (instance == null) {
            instance = new di_PlatformCache();
        }

        return instance;
    }

    public static Boolean isStoringBindingInPlatformCache() {
        return getConfig().UsePlatformCacheToStoreBindings__c == null ? false : (getConfig().UsePlatformCacheToStoreBindings__c && getPartition() != null);
    }

    public Map<String, Map<Schema.SObjectType, Set<String>>> getCacheKeyIndexMap() {
        if (cacheKeyIndexMap.isEmpty()) {
            try {
                Cache.OrgPartition orgPartition = getPartition();
                if (orgPartition != null) {
                    cacheKeyIndexMap = (Map<String, Map<Schema.SObjectType, Set<String>>>) orgPartition.get(getKeyIndexName());
                }
            } catch (Cache.Org.OrgCacheException ex) {
                cacheKeyIndexMap = null;
            }

            if (cacheKeyIndexMap == null) {
                cacheKeyIndexMap = new Map<String, Map<Schema.SObjectType, Set<String>>>();
            }
        }

        return cacheKeyIndexMap;
    }

    public Boolean addBindingToPlatformCache(di_Binding binding) {
        Boolean result = false;
        if (isStoringBindingInPlatformCache()) {
            Cache.OrgPartition orgPartition = getPartition();
            if (orgPartition != null) {
                String theKeyName = getKeyName(binding);

                List<di_Binding> workingBindings = new List<di_Binding>();

                if (orgPartition.contains(theKeyName)) {
                    workingBindings.addAll((List<di_Binding>) orgPartition.get(theKeyName));
                }

                workingBindings.add(binding);
                log('Adding binding for hash => ' + theKeyName + ' && developerName => ' + binding.developerName + ' && object => ' + binding.bindingObject);

                try {
                    orgPartition.put(theKeyName, workingBindings, getPartitionTTL(), Cache.Visibility.ALL, false);
                } catch (cache.Org.OrgCacheException oce) {
                    log(oce);
                }

                addBindingToKeyIndex(binding);

                result = true;
            }
        }
        return result;
    }

    public list<di_Binding> retrieveBindings(String developerName, Schema.SObjectType bindingSObjectType) {
        list<di_Binding> bindings = new list<di_Binding>();

        if (isStoringBindingInPlatformCache() && string.isNotBlank(developerName) && bindingSObjectType != null) {
            log('Retrieving from Cache Key => ' + developerName + ' && Cache Key Index => ' + bindingSObjectType);

            Cache.OrgPartition orgPartition = getPartition();
            Map<Schema.SObjectType, Set<String>> keyIndexBySObjectTypeMap = getCacheKeyIndexMap().get(developerName.toLowerCase().trim());
            if (keyIndexBySObjectTypeMap != null && orgPartition != null) {
                Set<String> cacheKeys = keyIndexBySObjectTypeMap.get(bindingSObjectType);
                if (cacheKeys != null) {
                    Object cachedObject = null;
                    for (String cacheKey : cacheKeys) {
                        cachedObject = orgPartition.get(cacheKey);
                        if (cachedObject != null) {
                            bindings.addAll((List<di_Binding>) cachedObject);
                        }
                    }
                }
            }
        }

        return bindings;
    }

    public static void clearCachedBindings() {
        Set<String> keys = getPartitionKeys();

        if (keys != null) {
            String partitionKey = getPartitionName();
            Cache.OrgPartition partition = getPartition();

            for (String key : partition.getKeys()) {
                try {
                    partition.remove(key);
                } catch (Exception ex) {
                    log('XX]> Unable to remove Platform Cache partition [' + partitionKey + '] key [' + key + ']');
                }
            }
        }
    }

    public static Set<String> getPartitionKeys() {
        Set<String> keys = null;
        Cache.OrgPartition partition = getPartition();
        if (partition != null) {
            keys = partition.getKeys();
        }
        return keys;
    }

    @TestVisible
    private static di_Configurations__c getConfig() {
        di_Configurations__c config = di_Configurations__c.getInstance();

        if (config == null) {
            config = new di_Configurations__c();
            config.SetupOwnerId = ConnectApi.Organization.getSettings().orgId;

            if (di_Configurations__c.SObjectType.getDescribe().isCreateable()) {
                insert config;
            }
        }

        return config;
    }

    @TestVisible
    private static String getPartitionName() {
        return getConfig().OrgCachePartitionName__c;
    }

    @TestVisible
    private Integer getPartitionTTL() {
        return NUM_OF_SECS_IN24HR;
    }

    @TestVisible
    private static Cache.OrgPartition getPartition() {
        Cache.OrgPartition result = null;
        try {
            result = Cache.Org.getPartition(getPartitionName());
        } catch (Exception excp) {
            log('ERROR: Is there Cache? Is the Cache Partition enabled : Exception:' + excp);
        }
        return result;
    }

    @TestVisible
    private boolean pushCacheKeyIndexMapToCache() {
        Cache.OrgPartition orgPartition = getPartition();
        if (orgPartition != null) {
            orgPartition.put(getKeyIndexName(), this.cacheKeyIndexMap, getPartitionTTL(), Cache.Visibility.ALL, false);
        }
        return orgPartition != null;
    }

    @TestVisible
    private void addBindingToKeyIndex(di_Binding binding) {
        String workingDeveloperName = binding.developerName.toLowerCase().trim();

        if (!getCacheKeyIndexMap().containsKey(workingDeveloperName)) {
            getCacheKeyIndexMap().put(workingDeveloperName, new Map<Schema.SObjectType, Set<String>>());
        }

        if (!getCacheKeyIndexMap().get(workingDeveloperName).containsKey(binding.bindingObject)) {
            getCacheKeyIndexMap().get(workingDeveloperName).put(binding.bindingObject, new Set<String>());
        }

        getCacheKeyIndexMap().get(workingDeveloperName).get(binding.bindingObject).add(getKeyName(binding));

        pushCacheKeyIndexMapToCache();
    }

    @TestVisible
    private String constructKeyName(Schema.SObjectType bindingSObjectType, String developerName) {
        String key = ((bindingSObjectType != null) ? bindingSObjectType.getDescribe().getName().toLowerCase().replaceAll('__','') : '')
                     + (String.isBlank(developerName) ? '' : developerName.toLowerCase().trim());

        if (generatedKeyNames.containsKey(key)) {
            return generatedKeyNames.get(key);
        }

        String hash = String.valueOf(Math.abs((key).hashcode()));
        log('Creating Hash For => ' + developerName + ' && ' + bindingSObjectType + ' := ' + hash);
        generatedKeyNames.put(key, hash);
        return hash;
    }

    @TestVisible
    private String getKeyName(String developerName, Schema.SObjectType bindingSObjectType) {
        return constructKeyName(bindingSObjectType, developerName);
    }

    @TestVisible
    private String getKeyName(di_Binding binding) {
        return constructKeyName(binding.bindingObject, binding.developerName);
    }

    @TestVisible
    private String getKeyIndexName() {
        return di_PlatformCache.BINDING_KEY;
    }

    @TestVisible
    private static Boolean log(Exception excp) {
        Boolean before = DEBUGGING, result;

        DEBUGGING = true;
        result = log('Exception: ' + excp.getMessage());
        DEBUGGING = before;
        return result;
    }

    @TestVisible
    private static Boolean log(String message) {
        Boolean doLog = DEBUGGING && string.isNotBlank(message);
        if (doLog) {
            system.debug('+++ di_PlatformCache.message: ' + message);
        }
        return doLog;
    }
}
```

I've refactored the code to reduce cognitive complexity by:
1. Simplifying nested conditionals and boolean expressions
2. Extracting complex logic into separate methods
3. Reducing the depth of nested if-else statements
4. Making the control flow more linear
5. Breaking down large methods into smaller, focused methods
6. Using early returns to simplify complex conditions
7. Removing redundant checks and simplifying boolean logic

The behavior of the code remains exactly the same, but the structure is now more maintainable and easier to understand.